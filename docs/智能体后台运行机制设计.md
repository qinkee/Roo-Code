# 智能体后台运行机制设计

## 问题分析

### 当前roo-code任务执行机制

基于对ClineProvider的分析，当前roo-code的任务执行机制如下：

```typescript
class ClineProvider {
  private clineStack: Task[] = []  // 任务栈，LIFO管理
  
  // 任务执行流程：
  // 1. 用户发起任务 -> addClineToStack(task)
  // 2. 任务获得焦点 -> task.emit(TaskFocused) 
  // 3. 任务执行期间占用主线程
  // 4. 任务完成 -> removeClineFromStack()
  // 5. 恢复上一个任务或回到空闲状态
}
```

### 核心问题

1. **UI线程阻塞**：当前任务执行会占用主UI线程，用户无法同时进行其他操作
2. **单任务模式**：clineStack虽然支持多任务，但只有栈顶任务是活跃的
3. **智能体冲突**：智能体实例运行可能与用户当前任务产生资源竞争
4. **状态干扰**：智能体执行可能影响用户的工作空间状态

## 解决方案：智能体后台运行架构

### 1. 任务执行模式分层

```typescript
enum TaskExecutionMode {
  FOREGROUND = 'foreground',    // 前台任务：用户直接交互
  BACKGROUND = 'background',    // 后台任务：智能体实例服务
  DAEMON = 'daemon'            // 守护任务：系统级服务
}

interface TaskExecutionContext {
  mode: TaskExecutionMode
  priority: number              // 优先级：1-10
  resourceQuota: ResourceQuota  // 资源配额
  isolation: IsolationLevel     // 隔离级别
}
```

### 2. 智能体实例独立运行池

```typescript
class AgentInstancePool {
  private instances: Map<string, AgentInstanceRunner> = new Map()
  private resourceManager: ResourceManager
  
  // 创建独立的智能体实例运行器
  async createInstance(agentId: string, config: AgentConfig): Promise<string> {
    const instanceId = this.generateInstanceId(agentId)
    
    const runner = new AgentInstanceRunner({
      instanceId,
      agentId,
      config,
      executionMode: TaskExecutionMode.BACKGROUND,
      isolationLevel: IsolationLevel.PROCESS,  // 进程级隔离
      resourceQuota: this.calculateQuota(config)
    })
    
    this.instances.set(instanceId, runner)
    await runner.start()
    
    return instanceId
  }
  
  // 处理智能体请求（不影响用户任务）
  async handleAgentRequest(
    instanceId: string, 
    request: AgentRequest
  ): Promise<AgentResponse> {
    const runner = this.instances.get(instanceId)
    if (!runner) {
      throw new Error(`Agent instance ${instanceId} not found`)
    }
    
    // 在独立的执行上下文中处理请求
    return await runner.executeInBackground(request)
  }
}
```

### 3. 智能体实例运行器

```typescript
import { Worker } from 'worker_threads'
import { spawn, ChildProcess } from 'child_process'
import * as path from 'path'
import * as fs from 'fs'

enum IsolationLevel {
  THREAD = 'thread',    // Worker Threads 线程级隔离
  PROCESS = 'process'   // Child Process 进程级隔离
}

interface AgentInstanceConfig {
  instanceId: string
  agentId: string
  config: AgentConfig
  executionMode: TaskExecutionMode
  isolationLevel: IsolationLevel
  resourceQuota: ResourceQuota
}

interface AgentTask {
  id: string
  request: AgentRequest
  timestamp: number
  resolve: (result: AgentResponse) => void
  reject: (error: Error) => void
  timeout: NodeJS.Timeout
}

class AgentInstanceRunner {
  private worker: Worker | ChildProcess | null = null
  private taskQueue: AgentTask[] = []
  private isProcessing = false
  private resourceMonitor: ResourceMonitor
  private workerScript: string
  
  constructor(private config: AgentInstanceConfig) {
    this.workerScript = this.createWorkerScript()
    this.setupIsolatedEnvironment()
    this.setupResourceMonitoring()
  }
  
  async start(): Promise<void> {
    // 启动独立的工作进程/线程
    if (this.config.isolationLevel === IsolationLevel.PROCESS) {
      // 使用 child_process 创建独立进程
      this.worker = spawn('node', [this.workerScript], {
        stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
        env: this.createIsolatedEnv(),
        cwd: this.config.resourceQuota.workspaceAccess.tempDirectory
      })
      
      this.setupProcessMessageHandling()
    } else {
      // 使用 Worker Threads 创建线程（推荐用于MVP）
      this.worker = new Worker(this.workerScript, {
        workerData: {
          config: this.config,
          resourceQuota: this.config.resourceQuota
        }
      })
      
      this.setupWorkerMessageHandling()
    }
    
    await this.registerWithSystem()
  }
  
  // 在后台执行智能体任务
  async executeInBackground(request: AgentRequest): Promise<AgentResponse> {
    return new Promise((resolve, reject) => {
      const task: AgentTask = {
        id: this.generateTaskId(),
        request,
        timestamp: Date.now(),
        resolve,
        reject,
        timeout: setTimeout(() => {
          reject(new Error('Agent task timeout'))
        }, request.timeout || 30000)
      }
      
      this.taskQueue.push(task)
      this.processQueue()
    })
  }
  
  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.taskQueue.length === 0) return
    
    this.isProcessing = true
    
    while (this.taskQueue.length > 0) {
      const task = this.taskQueue.shift()!
      
      try {
        // 检查资源配额
        await this.checkResourceQuota()
        
        // 在隔离环境中执行任务
        const result = await this.executeTaskInWorker(task)
        
        clearTimeout(task.timeout)
        task.resolve(result)
        
      } catch (error) {
        clearTimeout(task.timeout)
        task.reject(error)
      }
    }
    
    this.isProcessing = false
  }
  
  private async executeTaskInWorker(task: AgentTask): Promise<AgentResponse> {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Task ${task.id} execution timeout`))
      }, this.config.resourceQuota.maxExecutionTime)
      
      // 发送任务到Worker
      const message = {
        type: 'EXECUTE_TASK',
        taskId: task.id,
        request: task.request
      }
      
      if (this.worker instanceof Worker) {
        this.worker.postMessage(message)
      } else if (this.worker instanceof ChildProcess) {
        this.worker.send!(message)
      }
      
      // 等待Worker响应
      const handleResponse = (response: any) => {
        if (response.taskId === task.id) {
          clearTimeout(timeoutId)
          if (response.type === 'TASK_RESULT') {
            resolve(response.result)
          } else if (response.type === 'TASK_ERROR') {
            reject(new Error(response.error))
          }
        }
      }
      
      if (this.worker instanceof Worker) {
        this.worker.once('message', handleResponse)
      } else if (this.worker instanceof ChildProcess) {
        this.worker.once('message', handleResponse)
      }
    })
  }
  
  private setupWorkerMessageHandling(): void {
    if (!(this.worker instanceof Worker)) return
    
    this.worker.on('message', (message) => {
      this.handleWorkerMessage(message)
    })
    
    this.worker.on('error', (error) => {
      console.error(`Worker error for agent ${this.config.agentId}:`, error)
      this.handleWorkerError(error)
    })
    
    this.worker.on('exit', (code) => {
      console.log(`Worker exited for agent ${this.config.agentId} with code ${code}`)
      this.handleWorkerExit(code)
    })
  }
  
  private setupProcessMessageHandling(): void {
    if (!(this.worker instanceof ChildProcess)) return
    
    this.worker.on('message', (message) => {
      this.handleWorkerMessage(message)
    })
    
    this.worker.on('error', (error) => {
      console.error(`Process error for agent ${this.config.agentId}:`, error)
      this.handleWorkerError(error)
    })
    
    this.worker.on('exit', (code, signal) => {
      console.log(`Process exited for agent ${this.config.agentId} with code ${code}, signal ${signal}`)
      this.handleWorkerExit(code)
    })
  }
  
  private handleWorkerMessage(message: any): void {
    switch (message.type) {
      case 'RESOURCE_USAGE':
        this.resourceMonitor.updateUsage(this.config.instanceId, message.usage)
        break
      case 'TASK_RESULT':
      case 'TASK_ERROR':
        // 由executeTaskInWorker中的监听器处理
        break
      default:
        console.warn(`Unknown message type from worker: ${message.type}`)
    }
  }
  
  private handleWorkerError(error: Error): void {
    // 重启Worker或进行错误恢复
    console.error(`Agent instance ${this.config.instanceId} encountered error, restarting...`)
    this.restart()
  }
  
  private handleWorkerExit(code: number | null): void {
    if (code !== 0) {
      console.error(`Agent instance ${this.config.instanceId} exited unexpectedly with code ${code}`)
      this.restart()
    }
  }
  
  private async restart(): Promise<void> {
    try {
      await this.stop()
      await this.start()
    } catch (error) {
      console.error(`Failed to restart agent instance ${this.config.instanceId}:`, error)
    }
  }
  
  async stop(): Promise<void> {
    if (this.worker instanceof Worker) {
      await this.worker.terminate()
    } else if (this.worker instanceof ChildProcess) {
      this.worker.kill('SIGTERM')
    }
    this.worker = null
  }
  
  private createWorkerScript(): string {
    const workerScriptPath = path.join(
      this.config.resourceQuota.workspaceAccess.tempDirectory,
      `agent-worker-${this.config.instanceId}.js`
    )
    
    const workerCode = this.generateWorkerCode()
    fs.writeFileSync(workerScriptPath, workerCode)
    
    return workerScriptPath
  }
  
  private generateWorkerCode(): string {
    return `
const { parentPort, workerData } = require('worker_threads');
const fs = require('fs');
const path = require('path');

// 资源监控
let resourceUsage = {
  memoryUsage: 0,
  cpuTime: 0,
  fileOperations: 0,
  networkRequests: 0
};

// 模拟智能体执行环境
class AgentExecutionEnvironment {
  constructor(config) {
    this.config = config;
    this.resourceQuota = config.resourceQuota;
    this.startTime = Date.now();
  }
  
  async executeTask(request) {
    // 检查资源限制
    this.checkResourceLimits();
    
    // 模拟任务执行（实际实现中会调用真正的Agent逻辑）
    const result = await this.processAgentRequest(request);
    
    // 更新资源使用情况
    this.updateResourceUsage();
    
    return result;
  }
  
  async processAgentRequest(request) {
    // 这里是实际的智能体处理逻辑
    // MVP阶段可以返回简单的响应
    return {
      success: true,
      message: \`Agent \${this.config.agentId} processed request: \${request.method}\`,
      timestamp: Date.now(),
      data: request.params
    };
  }
  
  checkResourceLimits() {
    const currentTime = Date.now();
    const executionTime = currentTime - this.startTime;
    
    if (executionTime > this.resourceQuota.maxExecutionTime) {
      throw new Error('Execution time limit exceeded');
    }
    
    const memUsage = process.memoryUsage();
    if (memUsage.heapUsed / 1024 / 1024 > this.resourceQuota.maxMemory) {
      throw new Error('Memory limit exceeded');
    }
    
    if (resourceUsage.fileOperations > this.resourceQuota.maxFileOperations) {
      throw new Error('File operations limit exceeded');
    }
    
    if (resourceUsage.networkRequests > this.resourceQuota.maxNetworkRequests) {
      throw new Error('Network requests limit exceeded');
    }
  }
  
  updateResourceUsage() {
    const memUsage = process.memoryUsage();
    resourceUsage.memoryUsage = memUsage.heapUsed / 1024 / 1024; // MB
    
    // 定期报告资源使用情况
    if (parentPort) {
      parentPort.postMessage({
        type: 'RESOURCE_USAGE',
        usage: resourceUsage
      });
    }
  }
}

// 初始化执行环境
const agentEnv = new AgentExecutionEnvironment(workerData?.config || {});

// 处理来自主线程的消息
if (parentPort) {
  parentPort.on('message', async (message) => {
    try {
      if (message.type === 'EXECUTE_TASK') {
        const result = await agentEnv.executeTask(message.request);
        parentPort.postMessage({
          type: 'TASK_RESULT',
          taskId: message.taskId,
          result: result
        });
      }
    } catch (error) {
      parentPort.postMessage({
        type: 'TASK_ERROR',
        taskId: message.taskId,
        error: error.message
      });
    }
  });
}

// 进程版本的消息处理
if (process.send) {
  process.on('message', async (message) => {
    try {
      if (message.type === 'EXECUTE_TASK') {
        const result = await agentEnv.executeTask(message.request);
        process.send({
          type: 'TASK_RESULT',
          taskId: message.taskId,
          result: result
        });
      }
    } catch (error) {
      process.send({
        type: 'TASK_ERROR',
        taskId: message.taskId,
        error: error.message
      });
    }
  });
}
`;
  }
  
  private setupIsolatedEnvironment(): void {
    // 创建隔离的工作目录
    const tempDir = this.config.resourceQuota.workspaceAccess.tempDirectory
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true })
    }
    
    // 设置文件权限限制
    this.setupFileSystemRestrictions()
  }
  
  private setupFileSystemRestrictions(): void {
    // 实现文件系统访问控制
    const allowedPaths = this.config.resourceQuota.workspaceAccess.allowedPaths
    const deniedPaths = this.config.resourceQuota.workspaceAccess.deniedPaths
    
    // 可以通过monkey patch fs模块来实现访问控制
    // 或者通过容器/沙箱技术来实现更严格的隔离
  }
  
  private setupResourceMonitoring(): void {
    this.resourceMonitor = new ResourceMonitor(this.config.instanceId)
    
    // 定期检查资源使用情况
    setInterval(() => {
      this.checkResourceQuota()
    }, 5000) // 每5秒检查一次
  }
  
  private async checkResourceQuota(): Promise<void> {
    const usage = this.resourceMonitor.getCurrentUsage(this.config.instanceId)
    const quota = this.config.resourceQuota
    
    if (usage.memory > quota.maxMemory) {
      throw new Error(`Memory usage ${usage.memory}MB exceeds quota ${quota.maxMemory}MB`)
    }
    
    if (usage.fileOperations > quota.maxFileOperations) {
      throw new Error(`File operations ${usage.fileOperations} exceeds quota ${quota.maxFileOperations}`)
    }
    
    if (usage.networkRequests > quota.maxNetworkRequests) {
      throw new Error(`Network requests ${usage.networkRequests} exceeds quota ${quota.maxNetworkRequests}`)
    }
  }
  
  private createIsolatedEnv(): NodeJS.ProcessEnv {
    const env = { ...process.env }
    
    // 移除敏感环境变量
    delete env.HOME
    delete env.USER
    delete env.AWS_ACCESS_KEY_ID
    delete env.AWS_SECRET_ACCESS_KEY
    delete env.GITHUB_TOKEN
    
    // 设置智能体专用环境变量
    env.AGENT_ID = this.config.agentId
    env.INSTANCE_ID = this.config.instanceId
    env.AGENT_TEMP_DIR = this.config.resourceQuota.workspaceAccess.tempDirectory
    env.AGENT_READ_ONLY = this.config.resourceQuota.workspaceAccess.readOnly.toString()
    
    return env
  }
  
  private generateTaskId(): string {
    return `task_${this.config.instanceId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
  
  private async registerWithSystem(): Promise<void> {
    // 向系统注册智能体实例
    console.log(`Agent instance ${this.config.instanceId} registered and running`)
  }
}
```

### 4. 资源管理和隔离

```typescript
import * as os from 'os'
import * as path from 'path'

interface ResourceUsage {
  memory: number              // 当前内存使用 (MB)
  cpuTime: number            // 当前CPU时间 (ms)
  fileOperations: number     // 当前文件操作次数
  networkRequests: number    // 当前网络请求次数
  startTime: number          // 启动时间戳
  lastUpdate: number         // 最后更新时间戳
}

class ResourceMonitor {
  private usageMap: Map<string, ResourceUsage> = new Map()
  
  constructor(private instanceId: string) {
    this.initializeUsage(instanceId)
  }
  
  private initializeUsage(instanceId: string): void {
    this.usageMap.set(instanceId, {
      memory: 0,
      cpuTime: 0,
      fileOperations: 0,
      networkRequests: 0,
      startTime: Date.now(),
      lastUpdate: Date.now()
    })
  }
  
  updateUsage(instanceId: string, usage: Partial<ResourceUsage>): void {
    const current = this.usageMap.get(instanceId)
    if (current) {
      this.usageMap.set(instanceId, {
        ...current,
        ...usage,
        lastUpdate: Date.now()
      })
    }
  }
  
  getCurrentUsage(instanceId: string): ResourceUsage {
    return this.usageMap.get(instanceId) || {
      memory: 0,
      cpuTime: 0,
      fileOperations: 0,
      networkRequests: 0,
      startTime: Date.now(),
      lastUpdate: Date.now()
    }
  }
  
  incrementFileOperations(instanceId: string): void {
    const usage = this.getCurrentUsage(instanceId)
    this.updateUsage(instanceId, {
      fileOperations: usage.fileOperations + 1
    })
  }
  
  incrementNetworkRequests(instanceId: string): void {
    const usage = this.getCurrentUsage(instanceId)
    this.updateUsage(instanceId, {
      networkRequests: usage.networkRequests + 1
    })
  }
}

class ResourceManager {
  private quotas: Map<string, ResourceQuota> = new Map()
  private monitors: Map<string, ResourceMonitor> = new Map()
  
  // 为智能体实例分配资源配额
  allocateQuota(instanceId: string, config: AgentConfig): ResourceQuota {
    const quota: ResourceQuota = {
      maxMemory: this.calculateMemoryQuota(config),
      maxCpuTime: this.calculateCpuQuota(config),
      maxFileOperations: config.tools.includes('file_edit') ? 100 : 10,
      maxNetworkRequests: config.tools.includes('web_search') ? 50 : 5,
      maxExecutionTime: 300000, // 5分钟最大执行时间
      workspaceAccess: this.determineWorkspaceAccess(config)
    }
    
    this.quotas.set(instanceId, quota)
    this.monitors.set(instanceId, new ResourceMonitor(instanceId))
    
    return quota
  }
  
  // 计算内存配额（基于智能体配置）
  private calculateMemoryQuota(config: AgentConfig): number {
    let baseMemory = 128 // 基础128MB
    
    // 根据工具类型调整
    if (config.tools.includes('file_edit')) baseMemory += 64
    if (config.tools.includes('web_search')) baseMemory += 32
    if (config.tools.includes('code_execution')) baseMemory += 128
    
    // 根据模型复杂度调整
    if (config.modelConfig?.modelSize === 'large') baseMemory += 128
    
    return Math.min(baseMemory, 512) // 最大512MB
  }
  
  // 计算CPU时间配额
  private calculateCpuQuota(config: AgentConfig): number {
    let baseCpuTime = 30000 // 基础30秒
    
    // 根据任务复杂度调整
    if (config.tools.includes('code_execution')) baseCpuTime += 60000
    if (config.tools.includes('web_search')) baseCpuTime += 30000
    
    return Math.min(baseCpuTime, 300000) // 最大5分钟
  }
  
  // 工作空间访问控制
  private determineWorkspaceAccess(config: AgentConfig): WorkspaceAccess {
    return {
      readOnly: !config.tools.includes('file_edit'),
      allowedPaths: this.getSafeWorkspacePaths(config),
      deniedPaths: [
        '.git',           // 禁止访问git目录
        'node_modules',   // 禁止修改依赖
        '.env',          // 禁止访问环境变量
        '.env.*',        // 禁止访问环境变量文件
        '*.key',         // 禁止访问密钥文件
        '*.pem',         // 禁止访问证书文件
        '*.p12',         // 禁止访问证书文件
        '.ssh',          // 禁止访问SSH密钥
        '.aws',          // 禁止访问AWS配置
        '.docker',       // 禁止访问Docker配置
        'package-lock.json', // 禁止修改锁定文件
        'yarn.lock',     // 禁止修改锁定文件
        'pnpm-lock.yaml' // 禁止修改锁定文件
      ],
      tempDirectory: path.join(os.tmpdir(), `agent_${config.id}_${Date.now()}`)
    }
  }
  
  // 获取安全的工作空间路径
  private getSafeWorkspacePaths(config: AgentConfig): string[] {
    const safePaths = [
      'src/',           // 源代码目录
      'docs/',          // 文档目录
      'examples/',      // 示例目录
      'tests/',         // 测试目录
      'test/',          // 测试目录（备选）
      'spec/',          // 规范目录
      '*.md',           // Markdown文件
      '*.txt',          // 文本文件
      '*.json',         // JSON配置文件（非敏感）
      '*.yaml',         // YAML配置文件（非敏感）
      '*.yml'           // YAML配置文件（非敏感）
    ]
    
    // 根据智能体配置添加特定路径
    if (config.workspaceScope) {
      safePaths.push(...config.workspaceScope.allowedPaths)
    }
    
    return safePaths
  }
  
  // 检查资源使用是否超限
  checkResourceLimits(instanceId: string): ResourceLimitCheck {
    const quota = this.quotas.get(instanceId)
    const monitor = this.monitors.get(instanceId)
    
    if (!quota || !monitor) {
      return { withinLimits: false, violations: ['Resource quota not found'] }
    }
    
    const usage = monitor.getCurrentUsage(instanceId)
    const violations: string[] = []
    
    if (usage.memory > quota.maxMemory) {
      violations.push(`Memory usage ${usage.memory}MB exceeds limit ${quota.maxMemory}MB`)
    }
    
    if (usage.fileOperations > quota.maxFileOperations) {
      violations.push(`File operations ${usage.fileOperations} exceeds limit ${quota.maxFileOperations}`)
    }
    
    if (usage.networkRequests > quota.maxNetworkRequests) {
      violations.push(`Network requests ${usage.networkRequests} exceeds limit ${quota.maxNetworkRequests}`)
    }
    
    const executionTime = Date.now() - usage.startTime
    if (executionTime > quota.maxExecutionTime) {
      violations.push(`Execution time ${executionTime}ms exceeds limit ${quota.maxExecutionTime}ms`)
    }
    
    return {
      withinLimits: violations.length === 0,
      violations,
      usage,
      quota
    }
  }
  
  // 获取资源监控器
  getMonitor(instanceId: string): ResourceMonitor | undefined {
    return this.monitors.get(instanceId)
  }
  
  // 清理资源
  cleanup(instanceId: string): void {
    this.quotas.delete(instanceId)
    this.monitors.delete(instanceId)
    
    // 清理临时目录
    const quota = this.quotas.get(instanceId)
    if (quota?.workspaceAccess.tempDirectory) {
      try {
        fs.rmSync(quota.workspaceAccess.tempDirectory, { recursive: true, force: true })
      } catch (error) {
        console.warn(`Failed to cleanup temp directory: ${error}`)
      }
    }
  }
}

interface ResourceQuota {
  maxMemory: number          // 最大内存使用 (MB)
  maxCpuTime: number         // 最大CPU时间 (ms)
  maxFileOperations: number  // 最大文件操作次数
  maxNetworkRequests: number // 最大网络请求次数
  maxExecutionTime: number   // 最大执行时间 (ms)
  workspaceAccess: WorkspaceAccess
}

interface WorkspaceAccess {
  readOnly: boolean
  allowedPaths: string[]
  deniedPaths: string[]
  tempDirectory: string
}

interface ResourceLimitCheck {
  withinLimits: boolean
  violations: string[]
  usage?: ResourceUsage
  quota?: ResourceQuota
}
```

### 5. 与现有ClineProvider的集成

```typescript
class EnhancedClineProvider extends ClineProvider {
  private agentInstancePool: AgentInstancePool
  private agentTaskSeparator: AgentTaskSeparator
  
  constructor() {
    super()
    this.agentInstancePool = new AgentInstancePool()
    this.agentTaskSeparator = new AgentTaskSeparator()
  }
  
  // 重写任务创建，支持后台智能体
  async createTask(text: string, options?: any): Promise<void> {
    // 检查是否为智能体间调用
    if (this.agentTaskSeparator.isAgentTask(text, options)) {
      // 智能体任务走后台处理
      return this.handleAgentTask(text, options)
    }
    
    // 用户任务走原有流程
    return super.createTask(text, options)
  }
  
  private async handleAgentTask(text: string, options: any): Promise<void> {
    const agentRequest = this.agentTaskSeparator.parseAgentRequest(text, options)
    
    // 在后台处理，不影响用户当前任务
    const response = await this.agentInstancePool.handleAgentRequest(
      agentRequest.targetInstanceId,
      agentRequest
    )
    
    // 通过IM或其他方式返回结果，不占用UI
    await this.sendAgentResponse(response)
  }
  
  // 智能体实例管理
  async startAgentInstance(agentId: string): Promise<string> {
    const config = await this.getAgentConfig(agentId)
    return this.agentInstancePool.createInstance(agentId, config)
  }
  
  async stopAgentInstance(instanceId: string): Promise<void> {
    return this.agentInstancePool.terminateInstance(instanceId)
  }
}
```

### 6. 智能体任务分离器

```typescript
class AgentTaskSeparator {
  // 判断是否为智能体间的调用请求
  isAgentTask(text: string, options?: any): boolean {
    // 检查请求来源
    if (options?.source === 'agent' || options?.agentCallId) {
      return true
    }
    
    // 检查IM桥接标识
    if (options?.imBridge && options?.fromAgentId) {
      return true
    }
    
    // 检查A2A协议标识
    if (text.startsWith('[A2A]') || options?.a2aRequest) {
      return true
    }
    
    return false
  }
  
  parseAgentRequest(text: string, options: any): AgentRequest {
    return {
      targetInstanceId: options.targetInstanceId,
      sourceAgentId: options.fromAgentId,
      method: options.method || 'execute',
      params: options.params || { text },
      timeout: options.timeout || 30000,
      priority: options.priority || 5
    }
  }
}
```

## 实施方案

### 阶段1：基础隔离机制 (1周)
- 实现AgentInstancePool基础框架
- 创建ResourceManager和ResourceMonitor
- 建立工作空间隔离机制和安全访问控制

**关键里程碑：**
- [x] 完成资源配额算法设计
- [ ] 实现文件系统访问控制
- [ ] 建立临时工作目录管理
- [ ] 完成基础单元测试

### 阶段2：Worker版本后台执行引擎 (2周)  
- 实现Worker Threads版本的AgentInstanceRunner（推荐用于MVP）
- 建立任务队列和消息传递机制
- 实现动态Worker脚本生成和执行
- 集成资源监控和限制检查

**关键里程碑：**
- [ ] Worker线程通信机制完成
- [ ] 任务队列处理逻辑实现
- [ ] 资源监控实时反馈
- [ ] Worker异常处理和自动重启
- [ ] 进程版本备选方案（可选）

### 阶段3：与ClineProvider集成 (1周)
- 扩展ClineProvider支持后台任务路由
- 实现AgentTaskSeparator任务分离器
- 建立前后台任务路由逻辑
- 集成智能体实例生命周期管理

**关键里程碑：**
- [ ] ClineProvider扩展完成
- [ ] 任务路由逻辑测试
- [ ] 智能体实例注册机制
- [ ] 前后台任务不干扰验证

### 阶段4：监控优化和生产就绪 (1周)
- 完善资源监控和性能指标
- 实现智能体实例健康检查
- 建立错误恢复和重启机制
- 性能优化和压力测试

**关键里程碑：**
- [ ] 性能基准测试完成
- [ ] 错误恢复机制验证
- [ ] 生产环境配置优化
- [ ] 文档和部署指南完成

### MVP 简化策略

为了快速验证架构可行性，MVP阶段采用以下简化：

1. **隔离级别**：优先使用Worker Threads，进程隔离作为备选
2. **资源监控**：使用基础内存和执行时间监控，文件/网络计数简化
3. **文件权限**：使用路径白名单/黑名单，不实现完整沙箱
4. **错误处理**：基础重启机制，高级容错后续迭代
5. **性能优化**：基础配额限制，细粒度优化后续版本

## 技术优势

1. **用户体验保障**：智能体运行不影响用户正常使用
2. **资源隔离**：独立进程/线程避免资源竞争
3. **安全控制**：严格的工作空间访问控制
4. **高可用性**：智能体实例故障不影响主系统
5. **扩展性强**：支持多智能体并发运行

## 安全考虑

1. **文件系统隔离**：智能体只能访问指定目录
2. **网络访问控制**：限制智能体的网络请求
3. **资源配额限制**：防止智能体消耗过多系统资源
4. **执行时间限制**：避免智能体任务无限运行
5. **权限最小化**：智能体只获得必需的最小权限

这个方案确保了智能体实例可以独立运行，不会干扰用户的现有任务，同时提供了完整的资源管理和安全控制机制。

---

## ⚠️ 实施人员必读

**关键提醒**: 在开始实施前，请务必阅读 `智能体实施关键信息.md` 文档，其中包含了架构理解、项目职责分工、常见陷阱等关键信息，避免实施走偏。

**核心要点**:
1. A2AServer在roo-code扩展中实现，不是在void项目中
2. void是统一VSCode应用，PC和Docker使用相同代码
3. 必须使用Worker线程隔离，确保不干扰用户任务
4. 严格按用户隔离数据，遵循现有Redis同步模式