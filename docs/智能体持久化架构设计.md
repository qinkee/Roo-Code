# 智能体持久化架构设计

## 概述

本文档描述基于 Roo-Code 项目的智能体持久化机制和 A2A（Agent-to-Agent）通信架构设计。该架构支持用户级智能体隔离、跨终端数据同步、混合通信模式，并集成 a2a-js 协议实现智能体间的发现和协作。

## 核心设计原则

1. **KISS 原则**：扁平化设计，最简化实现，后续可扩展
2. **用户隔离**：智能体属于单个用户，支持私有/共享模式
3. **混合通信**：直连（云端）+ IM桥接（PC端）双模式
4. **Redis 双向同步**：类似现有 mode 模式的同步机制
5. **A2A 协议集成**：智能体发现、消息传递、数据共享

## 系统架构

### 整体架构图

```
                                智能体完整生产级架构
    ┌─────────────────────────────────────────────────────────────────────────────┐
    │                              用户与权限管理层                                │
    ├─────────────────────────────────────────────────────────────────────────────┤
    │  私有(0级)     好友(1级)        群组(2级)        公开(3级)                   │
    │  ┌─────────┐   ┌─────────┐    ┌─────────┐    ┌─────────┐                   │
    │  │ 仅所有者│   │好友白名单│    │群组白名单│    │所有认证 │                   │
    │  │ 可访问  │   │或好友关系│    │或共同群组│    │用户可访问│                   │
    │  └─────────┘   └─────────┘    └─────────┘    └─────────┘                   │
    └─────────────────────────────────────────────────────────────────────────────┘
                                          ↓
                                                           
    ┌─────────────────────────────────────────────────────────────────────────────┐
    │                        void项目 (标准VSCode应用)                             │
    ├─────────────────────────────────────────────────────────────────────────────┤
    │  void贡献点           wechat贡献点          roo-code扩展(built-in)             │
    │  ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────────────────┐ │
    │  │ • 智能体UI管理  │   │ • IM界面        │   │ • AgentInstancePool        │ │
    │  │ • 端点状态显示  │   │ • 桥接状态显示  │   │ • A2AServer (核心!)        │ │
    │  │ • 实例管理面板  │   │ • 消息路由界面  │   │ • AgentInstanceRunner      │ │
    │  │ • 命令注册      │   │ • 权限管理界面  │   │ • ResourceManager          │ │
    │  │ • 环境适配      │   │ • 智能体代理    │   │ • 后台执行引擎 (Worker)    │ │
    │  └─────────────────┘   └─────────────────┘   └─────────────────────────────┘ │
    └─────────────────────────────────────────────────────────────────────────────┘
                           ↓                    ↓                    ↓
                                                  
    ┌─────────────────────┐    ┌─────────────────────┐    ┌─────────────────────┐
    │   PC 环境部署       │    │   Docker 环境部署   │    │   box-im 平台       │
    │  (用户桌面)         │    │  (云端容器)         │    │  (IM桥接服务)       │
    ├─────────────────────┤    ├─────────────────────┤    ├─────────────────────┤
    │ • void桌面应用      │    │ • 相同void应用      │    │ • AgentBridgeService│
    │ • localhost:端口    │    │ • 容器IP:端口       │    │ • AgentMessageRouter│
    │ • 网络不可直达      │    │ • 公网可直达        │    │ • 权限代理服务      │
    │ • 依赖IM桥接        │    │ • 直连 + IM桥接     │    │ • 跨网络消息中转    │
    │ • 相同A2A服务器     │    │ • 相同A2A服务器     │    │ • 智能体发现代理    │
    └─────────────────────┘    └─────────────────────┘    └─────────────────────┘
               │                           │                           │
               └─────────────── ┌─────────────────────┐ ──────────────┘
                              │     Redis 注册中心    │
                              │  (统一状态管理)       │
                              ├─────────────────────┤
                              │ • 智能体注册表        │
                              │ • 多级别共享索引      │
                              │ • 权限缓存           │
                              │ • 在线状态管理        │
                              │ • 性能指标收集        │
                              └─────────────────────┘
                                          ↓
                    ┌─────────────────────────────────────────┐
                    │           共享范围索引结构               │
                    ├─────────────────────────────────────────┤
                    │ roo:shared:agents:friends  (好友级别)    │
                    │ roo:shared:agents:groups   (群组级别)    │
                    │ roo:shared:agents:public   (公开级别)    │
                    │ roo:shared:agents:level:1  (按级别1)     │
                    │ roo:shared:agents:level:2  (按级别2)     │
                    │ roo:shared:agents:level:3  (按级别3)     │
                    └─────────────────────────────────────────┘
```

### 核心组件

#### 1. 智能体管理器 (AgentManager)
- 整合所有智能体服务
- 管理智能体生命周期
- 处理用户切换和权限控制

#### 2. 持久化服务层
- **VSCodeAgentStorageService**: 本地存储
- **AgentRedisSyncService**: Redis 同步
- **EnhancedAgentStorageService**: 混合存储服务

#### 3. A2A 通信层
- **AgentA2AServer**: 本地 A2A 服务端
- **AgentRoutingService**: 智能路由
- **AgentIMBridge**: IM 桥接

#### 4. 注册发现服务
- **UnifiedAgentRegistry**: 统一注册中心
- **AgentDiscoveryService**: 智能体发现
- **AgentStatusManager**: 状态管理

## 数据结构设计

### 核心智能体配置

```typescript
interface AgentConfig {
  // 基础信息
  id: string
  userId: string
  name: string
  avatar: string
  roleDescription: string
  apiConfigId: string
  mode: string
  
  // 工具和能力
  tools: AgentToolConfig[]
  todos: AgentTodo[]
  
  // 新增：A2A 和共享配置
  isPrivate: boolean                    // 私有/共享标识
  shareScope?: 'friends' | 'groups' | 'public'  // 共享范围：好友、群组、公开
  shareLevel?: number                   // 共享级别：0=私有，1=好友，2=群组，3=公开
  a2aAgentCard?: A2AAgentCard          // A2A 协议智能体卡片
  a2aEndpoint?: string                 // A2A 服务端点
  permissions?: AgentPermission[]       // 访问权限
  allowedUsers?: string[]              // 好友级别：白名单用户ID
  allowedGroups?: string[]             // 群组级别：白名单群组ID
  
  // 元数据
  templateSource?: AgentTemplateSource
  createdAt: number
  updatedAt: number
  lastUsedAt?: number
  isActive: boolean
  version: number
}

interface A2AAgentCard {
  name: string
  description: string
  skills: string[]
  url?: string                         // 公网可访问的 A2A 端点
  capabilities: {
    messageTypes: string[]
    taskTypes: string[]
    dataFormats: string[]
  }
}

interface AgentPermission {
  action: 'read' | 'execute' | 'modify'
  resource: string
  conditions?: Record<string, any>
}
```

### 统一注册表结构

```typescript
interface UnifiedAgentRegistry {
  // 基础信息
  agentId: string
  userId: string
  name: string
  description: string
  avatar: string
  
  // 部署信息
  deploymentType: 'pc' | 'cloud' | 'docker' | 'serverless'
  environment: {
    platform: string                   // 'vscode' | 'docker' | 'k8s'
    version: string
    location?: string                   // 地理位置/区域
  }
  
  // 访问端点
  endpoint: {
    type: 'local_only' | 'network_reachable' | 'hybrid'
    
    // 直连信息（云端可选）
    direct?: {
      url: string
      protocol: 'http' | 'https' | 'ws' | 'wss'
      apiKey?: string
      healthCheck?: string
    }
    
    // IM桥接信息（必需）
    imBridge: {
      proxyId: string
      channelId?: string
    }
  }
  
  // 能力信息
  capabilities: {
    tools: string[]
    apis: string[]
    models?: string[]
    maxConcurrency?: number
  }
  
  // 状态信息
  status: {
    state: 'online' | 'offline' | 'busy' | 'error'
    lastSeen: number
    lastHealthCheck?: number
    currentLoad?: number
    errorCount?: number
  }
  
  // 共享设置
  sharing: {
    isPrivate: boolean
    shareScope?: 'friends' | 'groups' | 'public'  // 共享范围：好友、群组、公开
    allowedUsers?: string[]                       // 好友级别：允许的用户ID列表
    allowedGroups?: string[]                      // 群组级别：允许的群组ID列表
    permissions?: string[]                        // 具体权限列表
    shareLevel: number                            // 共享级别：0=私有，1=好友，2=群组，3=公开
  }
  
  // 元数据
  metadata: {
    createdAt: number
    updatedAt: number
    version: number
    tags?: string[]
  }
}
```

### Redis 数据结构

```typescript
class AgentRedisKeys {
  // 用户的所有智能体 (Hash)
  static userAgents(userId: string): string {
    return `roo:${userId}:agents`
  }
  
  // 单个智能体详细信息 (Hash)
  static agentDetails(agentId: string): string {
    return `roo:agent:${agentId}:details`
  }
  
  // 智能体状态 (String, TTL=60s)
  static agentStatus(agentId: string): string {
    return `roo:agent:${agentId}:status`
  }
  
  // 共享智能体索引 (Set) - 按共享级别分类
  static sharedAgents(shareLevel?: number): string {
    return shareLevel !== undefined 
      ? `roo:shared:agents:level:${shareLevel}`
      : `roo:shared:agents`
  }
  
  // 好友级别共享智能体 (Set)
  static friendsSharedAgents(): string {
    return `roo:shared:agents:friends`
  }
  
  // 群组级别共享智能体 (Set)
  static groupsSharedAgents(): string {
    return `roo:shared:agents:groups`
  }
  
  // 公开级别共享智能体 (Set)
  static publicSharedAgents(): string {
    return `roo:shared:agents:public`
  }
  
  // 智能体能力索引 (Set)
  static capabilityIndex(capability: string): string {
    return `roo:capability:${capability}:agents`
  }
  
  // 在线智能体集合 (Sorted Set, 按最后活跃时间)
  static onlineAgents(): string {
    return `roo:online:agents`
  }
  
  // 智能体负载信息 (Hash)
  static agentLoad(agentId: string): string {
    return `roo:agent:${agentId}:load`
  }
  
  // 智能体端点信息 (Hash)
  static agentEndpoint(agentId: string): string {
    return `roo:agent:${agentId}:endpoint`
  }
}
```

## 持久化机制

### 本地存储 (VSCodeAgentStorageService)

继续使用 VSCode GlobalState API 进行本地持久化：

```typescript
class VSCodeAgentStorageService implements AgentStorageService {
  private static readonly USER_AGENTS_PREFIX = "userAgents:"
  
  private getUserAgentsKey(userId: string): string {
    return `${VSCodeAgentStorageService.USER_AGENTS_PREFIX}${userId}`
  }
  
  async createAgent(
    userId: string, 
    config: Omit<AgentConfig, "id" | "createdAt" | "updatedAt">
  ): Promise<AgentConfig> {
    const now = Date.now()
    const agent: AgentConfig = {
      ...config,
      id: this.generateAgentId(),
      userId,
      createdAt: now,
      updatedAt: now,
      // 默认私有
      isPrivate: config.isPrivate ?? true,
    }
    
    const agents = await this.getUserAgents(userId)
    agents[agent.id] = agent
    await this.setUserAgents(userId, agents)
    
    return agent
  }
  
  // ... 其他现有方法保持不变
}
```

### Redis 同步服务 (AgentRedisSyncService)

增强现有的 Redis 同步机制：

```typescript
class AgentRedisSyncService {
  private redis = RedisSyncService.getInstance()
  private currentUserId?: string
  
  // 同步用户所有智能体到 Redis
  async syncUserAgents(userId: string, agents: AgentConfig[]): Promise<void> {
    if (!userId || userId === "default") {
      return
    }
    
    const pipeline = this.redis.pipeline()
    
    // 1. 同步到用户智能体表
    const userKey = AgentRedisKeys.userAgents(userId)
    for (const agent of agents) {
      pipeline.hset(userKey, agent.id, JSON.stringify(agent))
    }
    
    // 2. 同步详细信息和索引
    for (const agent of agents) {
      await this.syncSingleAgentToRedis(agent, pipeline)
    }
    
    await pipeline.exec()
  }
  
  // 同步单个智能体
  async syncSingleAgent(agent: AgentConfig): Promise<void> {
    if (!this.shouldSync(agent)) return
    
    const pipeline = this.redis.pipeline()
    await this.syncSingleAgentToRedis(agent, pipeline)
    await pipeline.exec()
  }
  
  private async syncSingleAgentToRedis(
    agent: AgentConfig, 
    pipeline: any
  ): Promise<void> {
    // 构建注册信息
    const registry: UnifiedAgentRegistry = {
      agentId: agent.id,
      userId: agent.userId,
      name: agent.name,
      description: agent.roleDescription,
      avatar: agent.avatar,
      
      deploymentType: 'pc', // PC端默认
      environment: {
        platform: 'vscode',
        version: '1.0.0'
      },
      
      endpoint: {
        type: 'local_only',
        imBridge: {
          proxyId: `proxy_${agent.id}`
        }
      },
      
      capabilities: {
        tools: agent.tools.map(t => t.toolId),
        apis: [],
        maxConcurrency: 1
      },
      
      status: {
        state: 'online',
        lastSeen: Date.now(),
        currentLoad: 0
      },
      
      sharing: {
        isPrivate: agent.isPrivate ?? true,
        shareScope: agent.shareScope,
        shareLevel: agent.shareLevel || 0,
        allowedUsers: agent.allowedUsers,
        allowedGroups: agent.allowedGroups
      },
      
      metadata: {
        createdAt: agent.createdAt,
        updatedAt: agent.updatedAt,
        version: agent.version
      }
    }
    
    // 保存详细信息
    pipeline.hset(
      AgentRedisKeys.agentDetails(agent.id),
      'data',
      JSON.stringify(registry)
    )
    
    // 更新状态
    pipeline.setex(
      AgentRedisKeys.agentStatus(agent.id),
      60,
      'online'
    )
    
    // 如果是共享智能体，加入相应的索引
    if (!agent.isPrivate) {
      const shareLevel = agent.shareLevel || 1
      
      // 加入总的共享索引
      pipeline.sadd(AgentRedisKeys.sharedAgents(), agent.id)
      
      // 按级别分类索引
      pipeline.sadd(AgentRedisKeys.sharedAgents(shareLevel), agent.id)
      
      // 具体范围索引
      switch (agent.shareScope) {
        case 'friends':
          pipeline.sadd(AgentRedisKeys.friendsSharedAgents(), agent.id)
          break
        case 'groups':
          pipeline.sadd(AgentRedisKeys.groupsSharedAgents(), agent.id)
          break
        case 'public':
          pipeline.sadd(AgentRedisKeys.publicSharedAgents(), agent.id)
          break
      }
    }
    
    // 更新能力索引
    for (const tool of agent.tools) {
      pipeline.sadd(AgentRedisKeys.capabilityIndex(tool.toolId), agent.id)
    }
    
    // 加入在线智能体集合
    pipeline.zadd(AgentRedisKeys.onlineAgents(), Date.now(), agent.id)
  }
  
  // 从 Redis 加载用户智能体
  async loadUserAgentsFromRedis(userId: string): Promise<AgentConfig[]> {
    try {
      const userKey = AgentRedisKeys.userAgents(userId)
      const data = await this.redis.hgetall(userKey)
      
      if (!data) return []
      
      return Object.values(data)
        .map(json => this.parseAgent(json))
        .filter(Boolean) as AgentConfig[]
    } catch (error) {
      console.error("[AgentRedisSyncService] Failed to load from Redis:", error)
      return []
    }
  }
  
  private parseAgent(json: string): AgentConfig | null {
    try {
      return JSON.parse(json)
    } catch {
      return null
    }
  }
  
  private shouldSync(agent: AgentConfig): boolean {
    return !!(this.currentUserId && agent.userId === this.currentUserId)
  }
}
```

### 增强存储服务 (EnhancedAgentStorageService)

保持现有的混合存储架构，增加 A2A 相关功能：

```typescript
class EnhancedAgentStorageService implements AgentStorageService {
  constructor(
    private baseStorageService: VSCodeAgentStorageService,
    private syncService: AgentRedisSyncService
  ) {}
  
  // 创建智能体时自动生成 A2A 卡片
  async createAgent(
    userId: string, 
    config: Omit<AgentConfig, "id" | "createdAt" | "updatedAt">
  ): Promise<AgentConfig> {
    // 自动生成 A2A 卡片
    const a2aCard: A2AAgentCard = {
      name: config.name,
      description: config.roleDescription,
      skills: config.tools.map(t => t.toolId),
      capabilities: {
        messageTypes: ['text', 'json'],
        taskTypes: ['execute', 'query'],
        dataFormats: ['json', 'markdown']
      }
    }
    
    const agentConfig = {
      ...config,
      a2aAgentCard: a2aCard,
      isPrivate: config.isPrivate ?? true,
      shareLevel: config.isPrivate ? 0 : (config.shareLevel || 1),
      shareScope: config.isPrivate ? undefined : config.shareScope
    }
    
    // 本地创建
    const agent = await this.baseStorageService.createAgent(userId, agentConfig)
    
    // 异步同步到 Redis
    this.syncService.syncSingleAgent(agent).catch(error =>
      console.debug("[EnhancedAgentStorageService] Sync failed:", error)
    )
    
    return agent
  }
  
  // ... 其他方法保持现有实现
}
```

## 用户系统集成

### 用户上下文管理

利用现有的 UserContextManager 和 VoidBridge：

```typescript
class AgentUserContextIntegration {
  private agentManager: AgentManager
  
  // 用户切换时更新智能体上下文
  async onUserSwitch(userId: string): Promise<void> {
    // 1. 设置智能体管理器的用户ID
    this.agentManager.setCurrentUserId(userId)
    
    // 2. 从 Redis 同步用户的智能体
    const storageService = this.agentManager.getStorageService()
    await storageService.restoreFromRedis(userId)
    
    // 3. 启动智能体本地服务
    await this.startAgentServices(userId)
  }
  
  private async startAgentServices(userId: string): Promise<void> {
    const agents = await this.agentManager.getStorageService()
      .listUserAgents(userId)
    
    // 为每个智能体启动 A2A 服务
    for (const agent of agents) {
      await this.startAgentA2AService(agent)
    }
  }
}
```

## 性能优化

### 缓存策略

1. **本地缓存优先**：优先使用 VSCode GlobalState
2. **Redis 缓存**：用户切换时从 Redis 快速恢复
3. **增量同步**：只同步变更的智能体
4. **批量操作**：使用 Redis Pipeline 减少网络开销

### 数据压缩

```typescript
class AgentDataCompression {
  // 压缩智能体数据
  static compress(agent: AgentConfig): string {
    // 移除冗余字段
    const compressed = {
      ...agent,
      // 移除大字段，只保留必要信息
      todos: agent.todos.slice(0, 10), // 只保留最近10个
    }
    return JSON.stringify(compressed)
  }
  
  // 解压缩数据
  static decompress(data: string): AgentConfig {
    return JSON.parse(data)
  }
}
```

## 安全机制

### 权限控制

```typescript
class AgentPermissionManager {
  // 检查用户是否可以访问智能体
  async checkAccess(
    userId: string, 
    agentId: string, 
    action: 'read' | 'execute' | 'modify'
  ): Promise<boolean> {
    const agent = await this.getAgent(agentId)
    if (!agent) return false
    
    // 1. 所有者永远有权限
    if (agent.userId === userId) return true
    
    // 2. 私有智能体只有所有者可访问
    if (agent.isPrivate || agent.shareLevel === 0) return false
    
    // 3. 根据共享范围检查权限
    switch (agent.shareScope) {
      case 'friends':
        // 好友级别：检查好友白名单
        if (agent.allowedUsers?.length) {
          return agent.allowedUsers.includes(userId)
        }
        // 如果没有白名单，需要检查是否为好友关系
        return await this.checkFriendship(agent.userId, userId)
        
      case 'groups':
        // 群组级别：检查群组白名单或共同群组
        if (agent.allowedGroups?.length) {
          const userGroups = await this.getUserGroups(userId)
          return agent.allowedGroups.some(group => userGroups.includes(group))
        }
        return await this.checkCommonGroups(agent.userId, userId)
        
      case 'public':
        // 公开级别：所有人可读，执行和修改需要额外检查
        if (action === 'read') return true
        break
    }
    
    // 4. 检查细粒度权限
    if (agent.permissions?.length) {
      return this.checkPermissions(userId, agent.permissions, action)
    }
    
    // 5. 默认策略：公开智能体只读，其他拒绝
    return agent.shareScope === 'public' && action === 'read'
  }
  
  // 检查好友关系
  private async checkFriendship(ownerId: string, userId: string): Promise<boolean> {
    // TODO: 实现好友关系检查逻辑
    // 可能需要查询用户服务或好友关系表
    return false
  }
  
  // 检查共同群组
  private async checkCommonGroups(ownerId: string, userId: string): Promise<boolean> {
    // TODO: 实现共同群组检查逻辑
    const ownerGroups = await this.getUserGroups(ownerId)
    const userGroups = await this.getUserGroups(userId)
    return ownerGroups.some(group => userGroups.includes(group))
  }
  
  // 获取用户所在群组
  private async getUserGroups(userId: string): Promise<string[]> {
    // TODO: 实现用户群组查询逻辑
    return []
  }
}
```

## 错误处理

### 容错机制

1. **Redis 不可用时降级到本地**
2. **同步失败时重试机制** 
3. **数据冲突时用户选择策略**
4. **智能体服务启动失败时告警**

### 监控指标

```typescript
interface AgentMetrics {
  totalAgents: number
  activeAgents: number
  syncSuccessRate: number
  avgResponseTime: number
  errorRate: number
}
```

## 总结

该架构设计基于 KISS 原则，充分复用现有组件，通过增量方式集成智能体持久化和 A2A 通信能力。主要特点：

1. **渐进式集成**：不破坏现有架构，增量添加功能
2. **双模式支持**：本地优先 + Redis 同步
3. **用户隔离**：完整的多用户支持
4. **扩展性强**：为 A2A 通信和云端部署预留接口
5. **性能优化**：缓存、压缩、批量操作

接下来将输出 A2A 通信架构的详细设计文档。

---

## ⚠️ 实施人员必读

**关键提醒**: 在开始实施前，请务必阅读 `智能体实施关键信息.md` 文档，其中包含了架构理解、项目职责分工、常见陷阱等关键信息，避免实施走偏。

**数据结构要点**:
1. AgentConfig扩展必须保持向后兼容
2. Redis键格式严格按 `roo:${userId}:` 模式
3. 共享范围字段默认私有，逐步开放权限
4. A2A卡片自动生成，与智能体配置同步