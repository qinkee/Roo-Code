# 智能体注册中心设计

## 概述

本文档详细描述基于 Redis 的统一智能体注册中心设计。该注册中心支持 PC 端和云端智能体的统一管理、实时状态同步、服务发现、负载均衡和权限控制。

## 设计目标

1. **统一注册**：PC 和云端智能体使用相同的注册机制
2. **实时同步**：状态变更实时更新，支持多终端同步
3. **分级共享**：支持私有、好友、群组、公开四级共享范围
4. **高可用性**：支持故障转移和自动恢复
5. **可扩展性**：支持水平扩展和分片存储
6. **安全性**：完整的权限控制和访问审计

## 共享范围架构图

```
                           智能体共享范围层级结构
    ┌─────────────────────────────────────────────────────────────────────┐
    │                        权限控制与访问管理                            │
    └─────────────────────────────────────────────────────────────────────┘
                                      ↓
    ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
    │ 私有(0) │  │ 好友(1) │  │ 群组(2) │  │ 公开(3) │  ← 共享级别递增
    ├─────────┤  ├─────────┤  ├─────────┤  ├─────────┤
    │仅所有者 │  │好友白名单│  │群组白名单│  │所有认证 │
    │可访问   │  │或好友关系│  │或共同群组│  │用户可访问│
    └─────────┘  └─────────┘  └─────────┘  └─────────┘
         ↓            ↓            ↓            ↓
    ┌─────────────────────────────────────────────────────────────────────┐
    │                     Redis 分级索引结构                              │
    ├─────────────────────────────────────────────────────────────────────┤
    │ • roo:shared:agents:friends    (好友级别智能体)                     │
    │ • roo:shared:agents:groups     (群组级别智能体)                     │
    │ • roo:shared:agents:public     (公开级别智能体)                     │
    │ • roo:shared:agents:level:1    (按级别1索引)                        │
    │ • roo:shared:agents:level:2    (按级别2索引)                        │
    │ • roo:shared:agents:level:3    (按级别3索引)                        │
    └─────────────────────────────────────────────────────────────────────┘
```

## Redis 数据结构设计

### 核心数据结构

#### 1. 智能体注册表

```redis
# 用户的所有智能体 (Hash)
# Key: roo:{userId}:agents
# Field: {agentId}
# Value: JSON(AgentRegistryInfo)

HSET roo:user123:agents agent_001 '{"agentId":"agent_001","name":"代码助手",...}'
HSET roo:user123:agents agent_002 '{"agentId":"agent_002","name":"文档生成器",...}'
```

#### 2. 智能体详细信息

```redis
# 智能体详细信息 (Hash)
# Key: roo:agent:{agentId}:details
# 存储完整的 UnifiedAgentRegistry 信息

HSET roo:agent:agent_001:details data '{"agentId":"agent_001","endpoint":...}'
HSET roo:agent:agent_001:details lastUpdate 1704067200000
HSET roo:agent:agent_001:details version 5
```

#### 3. 智能体状态管理

```redis
# 在线状态 (String with TTL)
# Key: roo:agent:{agentId}:status
# Value: online|offline|busy|error
# TTL: 60 seconds

SETEX roo:agent:agent_001:status 60 "online"

# 在线智能体集合 (Sorted Set)
# Key: roo:online:agents
# Score: 最后活跃时间戳
# Member: agentId

ZADD roo:online:agents 1704067200000 agent_001
ZADD roo:online:agents 1704067260000 agent_002
```

#### 4. 能力索引

```redis
# 按能力索引智能体 (Set)
# Key: roo:capability:{capability}:agents
# Member: agentId

SADD roo:capability:code_review:agents agent_001
SADD roo:capability:code_review:agents agent_003
SADD roo:capability:document_generation:agents agent_002
```

#### 5. 共享智能体索引

```redis
# 共享智能体列表 (Set)
# Key: roo:shared:agents
# Member: agentId

SADD roo:shared:agents agent_002
SADD roo:shared:agents agent_005

# 按共享级别分类的智能体索引 (Set)
# Key: roo:shared:agents:level:{level}
# Level: 1=好友，2=群组，3=公开

SADD roo:shared:agents:level:1 agent_002  # 好友级别
SADD roo:shared:agents:level:2 agent_003  # 群组级别  
SADD roo:shared:agents:level:3 agent_004  # 公开级别

# 按共享范围分类的智能体索引 (Set)
SADD roo:shared:agents:friends agent_002    # 好友共享
SADD roo:shared:agents:groups agent_003     # 群组共享
SADD roo:shared:agents:public agent_004     # 公开共享

# 智能体权限 (Hash)
# Key: roo:agent:{agentId}:permissions
# Field: userId|groupId
# Value: JSON(permissions)

HSET roo:agent:agent_002:permissions user456 '["read","execute"]'
HSET roo:agent:agent_002:permissions group_dev '["read"]'
```

#### 6. 负载和性能指标

```redis
# 智能体负载信息 (Hash)
# Key: roo:agent:{agentId}:load
# 用于负载均衡决策

HSET roo:agent:agent_001:load currentConnections 5
HSET roo:agent:agent_001:load avgResponseTime 150
HSET roo:agent:agent_001:load errorRate 0.02
HSET roo:agent:agent_001:load lastUpdate 1704067200000

# 性能历史 (Time Series)
# Key: roo:agent:{agentId}:metrics:{metric}
# 使用 Redis Streams 存储时间序列数据

XADD roo:agent:agent_001:metrics:response_time * time 1704067200000 value 150
XADD roo:agent:agent_001:metrics:error_rate * time 1704067200000 value 0.02
```

#### 7. 地理位置和区域

```redis
# 智能体地理位置 (Geo)
# Key: roo:agents:geo
# 用于就近路由

GEOADD roo:agents:geo 116.4074 39.9042 agent_beijing_001
GEOADD roo:agents:geo -74.0060 40.7128 agent_newyork_001

# 区域索引 (Set)
# Key: roo:region:{region}:agents

SADD roo:region:beijing:agents agent_beijing_001
SADD roo:region:newyork:agents agent_newyork_001
```

#### 8. 审计和日志

```redis
# 操作审计日志 (Stream)
# Key: roo:audit:agent_operations

XADD roo:audit:agent_operations * 
  action "register" 
  agentId "agent_001" 
  userId "user123" 
  timestamp 1704067200000 
  details '{"name":"代码助手"}'

# 调用统计 (Hash)
# Key: roo:stats:agent:{agentId}:daily:{date}

HINCRBY roo:stats:agent:agent_001:daily:20240101 total_calls 1
HINCRBY roo:stats:agent:agent_001:daily:20240101 success_calls 1
```

### 数据结构实现

#### 统一注册信息

```typescript
interface UnifiedAgentRegistry {
  // 基础信息
  agentId: string
  userId: string
  name: string
  description: string
  avatar: string
  
  // 部署信息
  deployment: {
    type: 'pc' | 'cloud' | 'docker' | 'serverless'
    platform: string                   // 'vscode' | 'docker' | 'k8s'
    version: string
    region?: string                     // 地理区域
    datacenter?: string                 // 数据中心
    environment?: 'dev' | 'staging' | 'prod'
  }
  
  // 网络端点
  endpoint: {
    type: 'local_with_standard_endpoint' | 'network_reachable' | 'hybrid'
    
    // 直连信息（所有智能体都有）
    direct: {
      url: string
      protocol: 'http' | 'https' | 'ws' | 'wss'
      port?: number
      apiKey?: string
      healthCheckPath: string
      networkReachable?: boolean       // 网络可达性状态（动态更新）
      lastProbeTime?: number          // 最后试探时间
      sslConfig?: {
        cert?: string
        key?: string
        ca?: string
      }
    }
    
    // IM桥接信息（所有智能体）
    imBridge: {
      proxyId: string
      channelId?: string
      priority: number                  // 路由优先级
    }
    
    // 负载均衡配置
    loadBalancing?: {
      weight: number                    // 权重
      maxConnections: number            // 最大连接数
      healthCheckInterval: number       // 健康检查间隔
    }
  }
  
  // 能力信息
  capabilities: {
    tools: string[]                     // 支持的工具
    apis: string[]                      // 提供的API
    models?: string[]                   // 支持的模型
    languages?: string[]                // 支持的语言
    maxConcurrency: number              // 最大并发数
    supportedFormats: string[]          // 支持的数据格式
    features: string[]                  // 特性标签
  }
  
  // 实时状态
  status: {
    state: 'online' | 'offline' | 'busy' | 'error' | 'maintenance'
    lastSeen: number
    lastHealthCheck?: number
    currentLoad: number                 // 当前负载 0-1
    errorCount: number                  // 累计错误次数
    errorRate: number                   // 错误率 0-1
    avgResponseTime: number             // 平均响应时间
    uptime: number                      // 运行时间
    memoryUsage?: number                // 内存使用率
    cpuUsage?: number                   // CPU使用率
  }
  
  // 配置和限制
  limits: {
    rateLimit: number                   // 每分钟请求限制
    quotaDaily: number                  // 每日调用配额
    timeoutMs: number                   // 超时时间
    maxPayloadSize: number              // 最大载荷大小
    allowedIPs?: string[]               // IP白名单
    blacklistedIPs?: string[]           // IP黑名单
  }
  
  // 共享和权限
  sharing: {
    isPrivate: boolean
    shareScope: 'friends' | 'groups' | 'public'  // 共享范围：好友、群组、公开
    shareLevel: number                           // 共享级别：0=私有，1=好友，2=群组，3=公开
    visibility: 'private' | 'friends' | 'groups' | 'public'
    allowedUsers?: string[]             // 好友级别：用户白名单
    allowedGroups?: string[]            // 群组级别：群组白名单
    deniedUsers?: string[]              // 用户黑名单
    permissions: AgentPermission[]      // 细粒度权限
    billing?: {
      model: 'free' | 'pay_per_use' | 'subscription'
      costPerCall?: number
      currency?: string
    }
  }
  
  // 元数据
  metadata: {
    createdAt: number
    updatedAt: number
    version: number
    tags: string[]                      // 标签
    category?: string                   // 分类
    author?: string                     // 作者
    license?: string                    // 许可证
    documentation?: string              // 文档链接
    sourceCode?: string                 // 源码链接
    changeLog?: ChangeLogEntry[]        // 变更记录
    dependencies?: string[]             // 依赖项
  }
}

interface AgentPermission {
  action: 'read' | 'execute' | 'modify' | 'admin'
  resource: string                      // 资源路径
  conditions?: {
    timeRange?: [number, number]        // 时间范围
    ipRange?: string[]                  // IP范围
    userAgent?: string                  // User-Agent限制
    maxUsage?: number                   // 使用次数限制
  }
}

interface ChangeLogEntry {
  version: string
  timestamp: number
  changes: string[]
  author: string
}
```

### Redis 键设计类

```typescript
class AgentRedisKeys {
  // 用户相关
  static userAgents(userId: string): string {
    return `roo:${userId}:agents`
  }
  
  static userQuota(userId: string): string {
    return `roo:${userId}:quota`
  }
  
  // 智能体基础信息
  static agentDetails(agentId: string): string {
    return `roo:agent:${agentId}:details`
  }
  
  static agentStatus(agentId: string): string {
    return `roo:agent:${agentId}:status`
  }
  
  static agentLoad(agentId: string): string {
    return `roo:agent:${agentId}:load`
  }
  
  static agentEndpoint(agentId: string): string {
    return `roo:agent:${agentId}:endpoint`
  }
  
  static agentConfig(agentId: string): string {
    return `roo:agent:${agentId}:config`
  }
  
  // 权限和共享
  static agentPermissions(agentId: string): string {
    return `roo:agent:${agentId}:permissions`
  }
  
  static agentAccessLog(agentId: string): string {
    return `roo:agent:${agentId}:access_log`
  }
  
  // 索引和查找
  static sharedAgents(): string {
    return `roo:shared:agents`
  }
  
  static sharedAgentsByLevel(level: number): string {
    return `roo:shared:agents:level:${level}`
  }
  
  static friendsSharedAgents(): string {
    return `roo:shared:agents:friends`
  }
  
  static groupsSharedAgents(): string {
    return `roo:shared:agents:groups`
  }
  
  static publicSharedAgents(): string {
    return `roo:shared:agents:public`
  }
  
  static onlineAgents(): string {
    return `roo:online:agents`
  }
  
  static capabilityIndex(capability: string): string {
    return `roo:capability:${capability}:agents`
  }
  
  static categoryIndex(category: string): string {
    return `roo:category:${category}:agents`
  }
  
  static tagIndex(tag: string): string {
    return `roo:tag:${tag}:agents`
  }
  
  // 地理位置
  static agentsGeo(): string {
    return `roo:agents:geo`
  }
  
  static regionAgents(region: string): string {
    return `roo:region:${region}:agents`
  }
  
  // 性能指标
  static agentMetrics(agentId: string, metric: string): string {
    return `roo:agent:${agentId}:metrics:${metric}`
  }
  
  static agentStats(agentId: string, period: string): string {
    return `roo:stats:agent:${agentId}:${period}`
  }
  
  // 系统级别
  static globalStats(): string {
    return `roo:stats:global`
  }
  
  static auditLog(): string {
    return `roo:audit:agent_operations`
  }
  
  static healthCheck(): string {
    return `roo:health:agents`
  }
  
  // 分布式锁
  static agentLock(agentId: string): string {
    return `roo:lock:agent:${agentId}`
  }
  
  static registryLock(): string {
    return `roo:lock:registry`
  }
}
```

## 核心服务实现

### 统一注册服务

```typescript
class UnifiedAgentRegistry {
  private redis: RedisSyncService
  private eventEmitter: EventEmitter
  private healthChecker: AgentHealthChecker
  private metricsCollector: AgentMetricsCollector
  
  constructor() {
    this.redis = RedisSyncService.getInstance()
    this.eventEmitter = new EventEmitter()
    this.healthChecker = new AgentHealthChecker(this)
    this.metricsCollector = new AgentMetricsCollector(this)
    
    // 启动后台任务
    this.startBackgroundTasks()
  }
  
  // 注册智能体
  async registerAgent(registry: UnifiedAgentRegistry): Promise<void> {
    const agentId = registry.agentId
    
    // 1. 获取分布式锁
    const lock = await this.acquireLock(AgentRedisKeys.agentLock(agentId))
    
    try {
      // 2. 验证注册信息
      await this.validateRegistry(registry)
      
      // 3. 保存到 Redis
      await this.saveToRedis(registry)
      
      // 4. 更新索引
      await this.updateIndexes(registry)
      
      // 5. 发送事件
      this.eventEmitter.emit('agentRegistered', registry)
      
      // 6. 记录审计日志
      await this.logOperation('register', registry)
      
      console.log(`Agent ${agentId} registered successfully`)
      
    } finally {
      await this.releaseLock(lock)
    }
  }
  
  // 保存到 Redis
  private async saveToRedis(registry: UnifiedAgentRegistry): Promise<void> {
    const pipeline = this.redis.pipeline()
    const agentId = registry.agentId
    const userId = registry.userId
    
    // 1. 保存到用户智能体列表
    pipeline.hset(
      AgentRedisKeys.userAgents(userId),
      agentId,
      JSON.stringify(this.serializeForUserList(registry))
    )
    
    // 2. 保存详细信息
    pipeline.hset(
      AgentRedisKeys.agentDetails(agentId),
      'data', JSON.stringify(registry),
      'lastUpdate', Date.now().toString(),
      'version', registry.metadata.version.toString()
    )
    
    // 3. 保存端点信息
    pipeline.hset(
      AgentRedisKeys.agentEndpoint(agentId),
      'type', registry.endpoint.type,
      'data', JSON.stringify(registry.endpoint)
    )
    
    // 4. 初始化状态
    pipeline.setex(
      AgentRedisKeys.agentStatus(agentId),
      60, // TTL 60秒
      registry.status.state
    )
    
    // 5. 初始化负载信息
    pipeline.hmset(
      AgentRedisKeys.agentLoad(agentId),
      'currentLoad', registry.status.currentLoad.toString(),
      'avgResponseTime', registry.status.avgResponseTime.toString(),
      'errorRate', registry.status.errorRate.toString(),
      'lastUpdate', Date.now().toString()
    )
    
    // 6. 保存权限信息
    if (registry.sharing.permissions.length > 0) {
      for (const permission of registry.sharing.permissions) {
        pipeline.hset(
          AgentRedisKeys.agentPermissions(agentId),
          `${permission.action}:${permission.resource}`,
          JSON.stringify(permission)
        )
      }
    }
    
    await pipeline.exec()
  }
  
  // 更新索引
  private async updateIndexes(registry: UnifiedAgentRegistry): Promise<void> {
    const pipeline = this.redis.pipeline()
    const agentId = registry.agentId
    
    // 1. 在线智能体集合
    if (registry.status.state === 'online') {
      pipeline.zadd(
        AgentRedisKeys.onlineAgents(),
        Date.now(),
        agentId
      )
    }
    
    // 2. 共享智能体索引
    if (!registry.sharing.isPrivate) {
      const shareLevel = registry.sharing.shareLevel || 1
      
      // 加入总的共享索引
      pipeline.sadd(AgentRedisKeys.sharedAgents(), agentId)
      
      // 按级别分类索引
      pipeline.sadd(AgentRedisKeys.sharedAgentsByLevel(shareLevel), agentId)
      
      // 具体范围索引
      switch (registry.sharing.shareScope) {
        case 'friends':
          pipeline.sadd(AgentRedisKeys.friendsSharedAgents(), agentId)
          break
        case 'groups':
          pipeline.sadd(AgentRedisKeys.groupsSharedAgents(), agentId)
          break
        case 'public':
          pipeline.sadd(AgentRedisKeys.publicSharedAgents(), agentId)
          break
      }
    }
    
    // 3. 能力索引
    for (const tool of registry.capabilities.tools) {
      pipeline.sadd(AgentRedisKeys.capabilityIndex(tool), agentId)
    }
    
    // 4. 分类索引
    if (registry.metadata.category) {
      pipeline.sadd(
        AgentRedisKeys.categoryIndex(registry.metadata.category),
        agentId
      )
    }
    
    // 5. 标签索引
    for (const tag of registry.metadata.tags) {
      pipeline.sadd(AgentRedisKeys.tagIndex(tag), agentId)
    }
    
    // 6. 地理位置索引
    if (registry.deployment.region) {
      pipeline.sadd(
        AgentRedisKeys.regionAgents(registry.deployment.region),
        agentId
      )
    }
    
    // 7. 全局统计
    pipeline.hincrby(AgentRedisKeys.globalStats(), 'totalAgents', 1)
    pipeline.hincrby(
      AgentRedisKeys.globalStats(),
      `${registry.deployment.type}Agents`,
      1
    )
    
    await pipeline.exec()
  }
  
  // 注销智能体
  async unregisterAgent(agentId: string): Promise<void> {
    const lock = await this.acquireLock(AgentRedisKeys.agentLock(agentId))
    
    try {
      // 1. 获取智能体信息
      const registry = await this.getAgentDetails(agentId)
      if (!registry) {
        throw new Error(`Agent ${agentId} not found`)
      }
      
      // 2. 从所有索引中移除
      await this.removeFromIndexes(registry)
      
      // 3. 删除数据
      await this.deleteFromRedis(agentId, registry.userId)
      
      // 4. 发送事件
      this.eventEmitter.emit('agentUnregistered', registry)
      
      // 5. 记录审计日志
      await this.logOperation('unregister', registry)
      
      console.log(`Agent ${agentId} unregistered successfully`)
      
    } finally {
      await this.releaseLock(lock)
    }
  }
  
  // 更新智能体状态
  async updateAgentStatus(
    agentId: string,
    status: Partial<AgentStatus>
  ): Promise<void> {
    const pipeline = this.redis.pipeline()
    
    // 1. 更新状态
    if (status.state) {
      pipeline.setex(
        AgentRedisKeys.agentStatus(agentId),
        60,
        status.state
      )
      
      // 更新在线列表
      if (status.state === 'online') {
        pipeline.zadd(AgentRedisKeys.onlineAgents(), Date.now(), agentId)
      } else {
        pipeline.zrem(AgentRedisKeys.onlineAgents(), agentId)
      }
    }
    
    // 2. 更新负载信息
    const loadUpdates: Record<string, string> = {}
    if (status.currentLoad !== undefined) {
      loadUpdates.currentLoad = status.currentLoad.toString()
    }
    if (status.avgResponseTime !== undefined) {
      loadUpdates.avgResponseTime = status.avgResponseTime.toString()
    }
    if (status.errorRate !== undefined) {
      loadUpdates.errorRate = status.errorRate.toString()
    }
    if (status.lastSeen) {
      loadUpdates.lastSeen = status.lastSeen.toString()
    }
    
    if (Object.keys(loadUpdates).length > 0) {
      loadUpdates.lastUpdate = Date.now().toString()
      pipeline.hmset(AgentRedisKeys.agentLoad(agentId), loadUpdates)
    }
    
    // 3. 更新详细信息中的状态
    const registry = await this.getAgentDetails(agentId)
    if (registry) {
      Object.assign(registry.status, status)
      registry.metadata.updatedAt = Date.now()
      
      pipeline.hset(
        AgentRedisKeys.agentDetails(agentId),
        'data', JSON.stringify(registry),
        'lastUpdate', Date.now().toString()
      )
    }
    
    await pipeline.exec()
  }
  
  // 心跳更新
  async heartbeat(agentId: string, metrics?: AgentMetrics): Promise<void> {
    const now = Date.now()
    const pipeline = this.redis.pipeline()
    
    // 1. 更新状态 TTL
    pipeline.setex(AgentRedisKeys.agentStatus(agentId), 60, 'online')
    
    // 2. 更新在线列表
    pipeline.zadd(AgentRedisKeys.onlineAgents(), now, agentId)
    
    // 3. 更新负载信息
    const loadUpdates: Record<string, string> = {
      lastSeen: now.toString(),
      lastUpdate: now.toString()
    }
    
    if (metrics) {
      if (metrics.currentLoad !== undefined) {
        loadUpdates.currentLoad = metrics.currentLoad.toString()
      }
      if (metrics.avgResponseTime !== undefined) {
        loadUpdates.avgResponseTime = metrics.avgResponseTime.toString()
      }
      if (metrics.errorRate !== undefined) {
        loadUpdates.errorRate = metrics.errorRate.toString()
      }
      if (metrics.memoryUsage !== undefined) {
        loadUpdates.memoryUsage = metrics.memoryUsage.toString()
      }
      if (metrics.cpuUsage !== undefined) {
        loadUpdates.cpuUsage = metrics.cpuUsage.toString()
      }
    }
    
    pipeline.hmset(AgentRedisKeys.agentLoad(agentId), loadUpdates)
    
    // 4. 记录性能时间序列
    if (metrics) {
      if (metrics.avgResponseTime !== undefined) {
        pipeline.xadd(
          AgentRedisKeys.agentMetrics(agentId, 'response_time'),
          '*',
          'time', now.toString(),
          'value', metrics.avgResponseTime.toString()
        )
      }
      if (metrics.errorRate !== undefined) {
        pipeline.xadd(
          AgentRedisKeys.agentMetrics(agentId, 'error_rate'),
          '*',
          'time', now.toString(),
          'value', metrics.errorRate.toString()
        )
      }
    }
    
    await pipeline.exec()
  }
}

interface AgentStatus {
  state: 'online' | 'offline' | 'busy' | 'error' | 'maintenance'
  lastSeen: number
  lastHealthCheck?: number
  currentLoad: number
  errorCount: number
  errorRate: number
  avgResponseTime: number
  uptime: number
  memoryUsage?: number
  cpuUsage?: number
}

interface AgentMetrics {
  currentLoad?: number
  avgResponseTime?: number
  errorRate?: number
  memoryUsage?: number
  cpuUsage?: number
  throughput?: number
  errorCount?: number
}
```

### 服务发现服务

```typescript
class AgentDiscoveryService {
  private registry: UnifiedAgentRegistry
  private cache: AgentCache
  
  constructor(registry: UnifiedAgentRegistry) {
    this.registry = registry
    this.cache = new AgentCache()
  }
  
  // 发现智能体
  async discoverAgents(query: AgentDiscoveryQuery): Promise<AgentDiscoveryResult[]> {
    // 1. 构建搜索条件
    const filters = this.buildFilters(query)
    
    // 2. 执行搜索
    const candidates = await this.searchAgents(filters)
    
    // 3. 应用权限过滤
    const authorized = await this.filterByPermissions(candidates, query.userId)
    
    // 4. 应用负载过滤
    const available = await this.filterByAvailability(authorized, query.requirements)
    
    // 5. 排序和分页
    const sorted = this.sortResults(available, query.sortBy, query.sortOrder)
    const paginated = this.paginate(sorted, query.offset, query.limit)
    
    return paginated
  }
  
  // 构建搜索过滤器
  private buildFilters(query: AgentDiscoveryQuery): SearchFilters {
    const filters: SearchFilters = {
      capabilities: query.capabilities || [],
      categories: query.categories || [],
      tags: query.tags || [],
      deploymentTypes: query.deploymentTypes || [],
      regions: query.regions || [],
      onlyOnline: query.onlyOnline ?? true,
      visibility: query.visibility || 'all'
    }
    
    return filters
  }
  
  // 搜索智能体
  private async searchAgents(filters: SearchFilters): Promise<AgentDiscoveryResult[]> {
    const results: AgentDiscoveryResult[] = []
    
    // 1. 基于能力搜索
    if (filters.capabilities.length > 0) {
      const capabilityResults = await this.searchByCapabilities(filters.capabilities)
      results.push(...capabilityResults)
    }
    
    // 2. 基于分类搜索
    if (filters.categories.length > 0) {
      const categoryResults = await this.searchByCategories(filters.categories)
      results.push(...categoryResults)
    }
    
    // 3. 基于标签搜索
    if (filters.tags.length > 0) {
      const tagResults = await this.searchByTags(filters.tags)
      results.push(...tagResults)
    }
    
    // 4. 如果没有指定搜索条件，返回所有共享智能体
    if (results.length === 0) {
      const allResults = await this.getAllSharedAgents()
      results.push(...allResults)
    }
    
    // 5. 去重
    const uniqueResults = this.deduplicateResults(results)
    
    // 6. 应用过滤器
    return this.applyFilters(uniqueResults, filters)
  }
  
  // 基于能力搜索
  private async searchByCapabilities(capabilities: string[]): Promise<AgentDiscoveryResult[]> {
    const results: AgentDiscoveryResult[] = []
    
    for (const capability of capabilities) {
      const agentIds = await this.redis.smembers(
        AgentRedisKeys.capabilityIndex(capability)
      )
      
      for (const agentId of agentIds) {
        const agent = await this.getAgentDiscoveryInfo(agentId)
        if (agent) {
          agent.matchedCapabilities = [capability]
          results.push(agent)
        }
      }
    }
    
    return results
  }
  
  // 智能推荐
  async recommendAgents(
    userId: string,
    context: RecommendationContext
  ): Promise<AgentRecommendation[]> {
    // 1. 获取用户历史使用记录
    const userHistory = await this.getUserUsageHistory(userId)
    
    // 2. 分析用户偏好
    const preferences = this.analyzeUserPreferences(userHistory)
    
    // 3. 基于协同过滤推荐
    const collaborativeRecommendations = await this.collaborativeFiltering(userId, preferences)
    
    // 4. 基于内容的推荐
    const contentBasedRecommendations = await this.contentBasedRecommendation(context, preferences)
    
    // 5. 混合推荐算法
    const hybridRecommendations = this.hybridRecommendation(
      collaborativeRecommendations,
      contentBasedRecommendations
    )
    
    // 6. 过滤和排序
    const filtered = await this.filterRecommendations(hybridRecommendations, userId)
    const sorted = this.sortRecommendations(filtered, preferences)
    
    return sorted.slice(0, 10) // 返回前10个推荐
  }
  
  // 智能体负载均衡选择
  async selectOptimalAgent(
    capability: string,
    userId: string,
    requirements?: PerformanceRequirements
  ): Promise<AgentDiscoveryResult | null> {
    // 1. 获取具有该能力的所有智能体
    const candidates = await this.discoverAgents({
      capabilities: [capability],
      userId,
      onlyOnline: true,
      sortBy: 'performance',
      sortOrder: 'desc'
    })
    
    if (candidates.length === 0) {
      return null
    }
    
    // 2. 应用性能要求过滤
    const eligible = requirements 
      ? this.filterByPerformanceRequirements(candidates, requirements)
      : candidates
    
    if (eligible.length === 0) {
      return null
    }
    
    // 3. 负载均衡算法选择
    return this.loadBalancingSelection(eligible)
  }
  
  // 负载均衡选择算法
  private loadBalancingSelection(agents: AgentDiscoveryResult[]): AgentDiscoveryResult {
    // 加权轮询算法
    let bestAgent = agents[0]
    let bestScore = -Infinity
    
    for (const agent of agents) {
      const score = this.calculateAgentScore(agent)
      if (score > bestScore) {
        bestScore = score
        bestAgent = agent
      }
    }
    
    return bestAgent
  }
  
  // 智能体评分算法
  private calculateAgentScore(agent: AgentDiscoveryResult): number {
    const load = agent.currentLoad || 0
    const errorRate = agent.errorRate || 0
    const responseTime = agent.avgResponseTime || 1000
    
    // 基础分数
    let score = 100
    
    // 负载惩罚 (负载越高，分数越低)
    score -= load * 30
    
    // 错误率惩罚
    score -= errorRate * 40
    
    // 响应时间惩罚 (响应时间越长，分数越低)
    score -= Math.min(responseTime / 100, 20)
    
    // 部署类型加成
    switch (agent.deploymentType) {
      case 'cloud':
        score += 20  // 云端智能体优势
        break
      case 'docker':
        score += 15  // 容器化部署优势
        break
      case 'pc':
        score += 5   // PC端相对劣势
        break
    }
    
    // 网络连接类型加成
    if (agent.endpointType === 'network_reachable') {
      score += 10  // 直连优势
    }
    
    // 地理位置加成 (TODO: 实现就近选择)
    
    return score
  }
}

// 搜索和发现相关类型
interface AgentDiscoveryQuery {
  userId: string
  capabilities?: string[]
  categories?: string[]
  tags?: string[]
  deploymentTypes?: string[]
  regions?: string[]
  keywords?: string
  onlyOnline?: boolean
  visibility?: 'private' | 'friends' | 'groups' | 'public' | 'all'
  shareScope?: 'friends' | 'groups' | 'public'
  shareLevel?: number
  requirements?: PerformanceRequirements
  sortBy?: 'relevance' | 'performance' | 'popularity' | 'rating'
  sortOrder?: 'asc' | 'desc'
  offset?: number
  limit?: number
}

interface AgentDiscoveryResult {
  agentId: string
  userId: string
  name: string
  description: string
  avatar: string
  
  // 匹配信息
  matchedCapabilities: string[]
  relevanceScore: number
  
  // 部署信息
  deploymentType: 'pc' | 'cloud' | 'docker' | 'serverless'
  region?: string
  endpointType: 'local_only' | 'network_reachable' | 'hybrid'
  
  // 性能指标
  currentLoad: number
  avgResponseTime: number
  errorRate: number
  availability: number
  
  // 使用统计
  totalCalls: number
  successRate: number
  rating?: number
  
  // 权限信息
  isPrivate: boolean
  hasAccess: boolean
  
  // 元数据
  category?: string
  tags: string[]
  createdAt: number
  lastUsed?: number
}

interface PerformanceRequirements {
  maxResponseTime?: number    // 最大响应时间 (ms)
  minAvailability?: number    // 最小可用性 (0-1)
  maxErrorRate?: number       // 最大错误率 (0-1)
  minThroughput?: number      // 最小吞吐量 (req/s)
  maxLoad?: number           // 最大负载 (0-1)
}
```

### 权限管理服务

```typescript
class AgentPermissionService {
  private registry: UnifiedAgentRegistry
  
  // 检查访问权限
  async checkAccess(
    userId: string,
    agentId: string,
    action: 'read' | 'execute' | 'modify' | 'admin',
    context?: AccessContext
  ): Promise<AccessResult> {
    try {
      // 1. 获取智能体信息
      const agent = await this.registry.getAgentDetails(agentId)
      if (!agent) {
        return { allowed: false, reason: 'Agent not found' }
      }
      
      // 2. 所有者永远有权限
      if (agent.userId === userId) {
        return { allowed: true, reason: 'Owner access' }
      }
      
      // 3. 检查私有状态
      if (agent.sharing.isPrivate || agent.sharing.shareLevel === 0) {
        return { allowed: false, reason: 'Private agent' }
      }
      
      // 4. 检查可见性
      const visibilityCheck = await this.checkVisibility(agent, userId)
      if (!visibilityCheck.allowed) {
        return visibilityCheck
      }
      
      // 5. 检查黑名单
      if (agent.sharing.deniedUsers?.includes(userId)) {
        return { allowed: false, reason: 'User denied' }
      }
      
      // 6. 检查白名单
      if (agent.sharing.allowedUsers?.length > 0) {
        if (!agent.sharing.allowedUsers.includes(userId)) {
          return { allowed: false, reason: 'User not in whitelist' }
        }
      }
      
      // 7. 检查群组权限
      if (agent.sharing.allowedGroups?.length > 0) {
        const userGroups = await this.getUserGroups(userId)
        const hasGroupAccess = agent.sharing.allowedGroups.some(group =>
          userGroups.includes(group)
        )
        if (!hasGroupAccess) {
          return { allowed: false, reason: 'User not in allowed groups' }
        }
      }
      
      // 8. 检查细粒度权限
      const permissionCheck = await this.checkDetailedPermissions(
        agent, userId, action, context
      )
      if (!permissionCheck.allowed) {
        return permissionCheck
      }
      
      // 9. 检查配额和限制
      const quotaCheck = await this.checkQuotaAndLimits(agent, userId, context)
      if (!quotaCheck.allowed) {
        return quotaCheck
      }
      
      return { allowed: true, reason: 'Permission granted' }
      
    } catch (error) {
      return { 
        allowed: false, 
        reason: `Permission check failed: ${error.message}` 
      }
    }
  }
  
  // 检查细粒度权限
  private async checkDetailedPermissions(
    agent: UnifiedAgentRegistry,
    userId: string,
    action: string,
    context?: AccessContext
  ): Promise<AccessResult> {
    if (!agent.sharing.permissions || agent.sharing.permissions.length === 0) {
      // 没有细粒度权限，使用默认规则
      return this.checkDefaultPermissions(action)
    }
    
    for (const permission of agent.sharing.permissions) {
      if (permission.action === action || permission.action === 'admin') {
        // 检查条件
        if (permission.conditions) {
          const conditionCheck = await this.checkPermissionConditions(
            permission.conditions, userId, context
          )
          if (!conditionCheck) {
            continue
          }
        }
        
        return { allowed: true, reason: 'Permission rule matched' }
      }
    }
    
    return { allowed: false, reason: 'No matching permission rule' }
  }
  
  // 检查权限条件
  private async checkPermissionConditions(
    conditions: any,
    userId: string,
    context?: AccessContext
  ): Promise<boolean> {
    // 时间范围检查
    if (conditions.timeRange) {
      const now = Date.now()
      const [start, end] = conditions.timeRange
      if (now < start || now > end) {
        return false
      }
    }
    
    // IP 范围检查
    if (conditions.ipRange && context?.clientIP) {
      const allowed = conditions.ipRange.some((range: string) =>
        this.isIPInRange(context.clientIP!, range)
      )
      if (!allowed) {
        return false
      }
    }
    
    // 使用次数限制
    if (conditions.maxUsage) {
      const usageCount = await this.getUserUsageCount(userId)
      if (usageCount >= conditions.maxUsage) {
        return false
      }
    }
    
    // User-Agent 检查
    if (conditions.userAgent && context?.userAgent) {
      if (!context.userAgent.includes(conditions.userAgent)) {
        return false
      }
    }
    
    return true
  }
  
  // 检查配额和限制
  private async checkQuotaAndLimits(
    agent: UnifiedAgentRegistry,
    userId: string,
    context?: AccessContext
  ): Promise<AccessResult> {
    // 1. 检查速率限制
    const rateLimit = agent.limits.rateLimit
    if (rateLimit > 0) {
      const currentRate = await this.getUserCurrentRate(userId, agent.agentId)
      if (currentRate >= rateLimit) {
        return { 
          allowed: false, 
          reason: `Rate limit exceeded: ${rateLimit} requests per minute` 
        }
      }
    }
    
    // 2. 检查日配额
    const dailyQuota = agent.limits.quotaDaily
    if (dailyQuota > 0) {
      const dailyUsage = await this.getUserDailyUsage(userId, agent.agentId)
      if (dailyUsage >= dailyQuota) {
        return { 
          allowed: false, 
          reason: `Daily quota exceeded: ${dailyQuota} calls per day` 
        }
      }
    }
    
    // 3. 检查 IP 白名单
    if (agent.limits.allowedIPs?.length > 0 && context?.clientIP) {
      const allowed = agent.limits.allowedIPs.some(ip =>
        this.isIPInRange(context.clientIP!, ip)
      )
      if (!allowed) {
        return { allowed: false, reason: 'IP not in whitelist' }
      }
    }
    
    // 4. 检查 IP 黑名单
    if (agent.limits.blacklistedIPs?.length > 0 && context?.clientIP) {
      const blocked = agent.limits.blacklistedIPs.some(ip =>
        this.isIPInRange(context.clientIP!, ip)
      )
      if (blocked) {
        return { allowed: false, reason: 'IP blacklisted' }
      }
    }
    
    return { allowed: true, reason: 'Limits check passed' }
  }
  
  // 记录访问日志
  async logAccess(
    userId: string,
    agentId: string,
    action: string,
    result: AccessResult,
    context?: AccessContext
  ): Promise<void> {
    const logEntry = {
      timestamp: Date.now(),
      userId,
      agentId,
      action,
      allowed: result.allowed,
      reason: result.reason,
      clientIP: context?.clientIP,
      userAgent: context?.userAgent,
      requestId: context?.requestId
    }
    
    // 记录到 Redis Stream
    await this.redis.xadd(
      AgentRedisKeys.agentAccessLog(agentId),
      '*',
      ...Object.entries(logEntry).flat()
    )
    
    // 更新使用统计
    if (result.allowed) {
      await this.updateUsageStats(userId, agentId)
    }
  }
}

interface AccessContext {
  clientIP?: string
  userAgent?: string
  requestId?: string
  timestamp?: number
}

interface AccessResult {
  allowed: boolean
  reason: string
  ttl?: number          // 权限缓存时间
  metadata?: any        // 额外元数据
}
```

## 性能优化

### 缓存策略

```typescript
class AgentRegistryCache {
  private localCache: Map<string, CacheEntry> = new Map()
  private redisCache: RedisSyncService
  
  // 多层缓存架构
  async get(key: string): Promise<any> {
    // 1. 本地缓存
    const localEntry = this.localCache.get(key)
    if (localEntry && !this.isExpired(localEntry)) {
      return localEntry.data
    }
    
    // 2. Redis 缓存
    const redisData = await this.redisCache.get(`cache:${key}`)
    if (redisData) {
      this.setLocal(key, redisData, 60000) // 本地缓存1分钟
      return redisData
    }
    
    return null
  }
  
  async set(key: string, data: any, ttl: number = 300000): Promise<void> {
    // 1. 设置本地缓存
    this.setLocal(key, data, Math.min(ttl, 60000))
    
    // 2. 设置 Redis 缓存
    await this.redisCache.setex(`cache:${key}`, ttl / 1000, data)
  }
  
  // 缓存失效策略
  async invalidate(pattern: string): Promise<void> {
    // 1. 清除匹配的本地缓存
    for (const [key] of this.localCache) {
      if (key.includes(pattern)) {
        this.localCache.delete(key)
      }
    }
    
    // 2. 清除 Redis 缓存
    const keys = await this.redisCache.keys(`cache:*${pattern}*`)
    if (keys.length > 0) {
      await this.redisCache.del(...keys)
    }
  }
}
```

### 分片和扩展

```typescript
class ShardedAgentRegistry {
  private shards: Map<string, UnifiedAgentRegistry>
  private hashRing: ConsistentHashRing
  
  constructor(shardConfigs: ShardConfig[]) {
    this.shards = new Map()
    this.hashRing = new ConsistentHashRing()
    
    // 初始化分片
    for (const config of shardConfigs) {
      const registry = new UnifiedAgentRegistry(config.redisConfig)
      this.shards.set(config.shardId, registry)
      this.hashRing.addNode(config.shardId, config.weight)
    }
  }
  
  // 根据智能体 ID 选择分片
  private selectShard(agentId: string): UnifiedAgentRegistry {
    const shardId = this.hashRing.getNode(agentId)
    return this.shards.get(shardId)!
  }
  
  // 注册智能体（自动分片）
  async registerAgent(registry: UnifiedAgentRegistry): Promise<void> {
    const shard = this.selectShard(registry.agentId)
    return shard.registerAgent(registry)
  }
  
  // 跨分片搜索
  async searchAgents(query: AgentDiscoveryQuery): Promise<AgentDiscoveryResult[]> {
    const searchPromises = Array.from(this.shards.values()).map(shard =>
      shard.discoverAgents(query)
    )
    
    const results = await Promise.all(searchPromises)
    const combined = results.flat()
    
    // 合并和排序结果
    return this.mergeAndSort(combined, query.sortBy, query.limit)
  }
}
```

## 监控和运维

### 健康检查

```typescript
class AgentHealthChecker {
  private registry: UnifiedAgentRegistry
  private checkInterval = 30000 // 30秒检查一次
  
  // 启动健康检查
  start(): void {
    setInterval(() => this.performHealthCheck(), this.checkInterval)
  }
  
  // 执行健康检查
  private async performHealthCheck(): Promise<void> {
    const onlineAgents = await this.getOnlineAgents()
    
    const healthChecks = onlineAgents.map(agentId =>
      this.checkAgentHealth(agentId).catch(error => ({
        agentId,
        healthy: false,
        error: error.message,
        timestamp: Date.now()
      }))
    )
    
    const results = await Promise.allSettled(healthChecks)
    
    // 处理检查结果
    for (const result of results) {
      if (result.status === 'fulfilled') {
        await this.handleHealthResult(result.value)
      }
    }
  }
  
  private async checkAgentHealth(agentId: string): Promise<HealthCheckResult> {
    const agent = await this.registry.getAgentDetails(agentId)
    if (!agent) {
      return { agentId, healthy: false, error: 'Agent not found' }
    }
    
    // 检查心跳时间
    const lastSeen = agent.status.lastSeen
    const timeSinceLastSeen = Date.now() - lastSeen
    
    if (timeSinceLastSeen > 120000) { // 2分钟无心跳
      return { 
        agentId, 
        healthy: false, 
        error: `No heartbeat for ${timeSinceLastSeen}ms` 
      }
    }
    
    // 对于云端智能体，执行主动健康检查
    if (agent.endpoint.type === 'network_reachable') {
      return this.activeHealthCheck(agent)
    }
    
    return { agentId, healthy: true }
  }
  
  private async activeHealthCheck(agent: UnifiedAgentRegistry): Promise<HealthCheckResult> {
    try {
      const healthUrl = `${agent.endpoint.direct!.url}${agent.endpoint.direct!.healthCheckPath}`
      
      const response = await fetch(healthUrl, {
        method: 'GET',
        timeout: 5000,
        headers: agent.endpoint.direct!.apiKey ? {
          'Authorization': `Bearer ${agent.endpoint.direct!.apiKey}`
        } : {}
      })
      
      if (response.ok) {
        const data = await response.json()
        return {
          agentId: agent.agentId,
          healthy: true,
          responseTime: Date.now() - performance.now(),
          metadata: data
        }
      } else {
        return {
          agentId: agent.agentId,
          healthy: false,
          error: `Health check failed: ${response.status}`
        }
      }
    } catch (error) {
      return {
        agentId: agent.agentId,
        healthy: false,
        error: error.message
      }
    }
  }
}
```

### 指标收集

```typescript
class AgentMetricsCollector {
  // 收集系统级别指标
  async collectSystemMetrics(): Promise<SystemMetrics> {
    const totalAgents = await this.redis.hget(AgentRedisKeys.globalStats(), 'totalAgents')
    const onlineAgents = await this.redis.zcard(AgentRedisKeys.onlineAgents())
    
    return {
      totalAgents: parseInt(totalAgents || '0'),
      onlineAgents,
      registrationRate: await this.getRegistrationRate(),
      avgResponseTime: await this.getAverageResponseTime(),
      errorRate: await this.getSystemErrorRate(),
      throughput: await this.getSystemThroughput()
    }
  }
  
  // 收集智能体级别指标
  async collectAgentMetrics(agentId: string): Promise<AgentDetailedMetrics> {
    const loadInfo = await this.redis.hgetall(AgentRedisKeys.agentLoad(agentId))
    const dailyStats = await this.getDailyStats(agentId)
    
    return {
      agentId,
      currentLoad: parseFloat(loadInfo.currentLoad || '0'),
      avgResponseTime: parseFloat(loadInfo.avgResponseTime || '0'),
      errorRate: parseFloat(loadInfo.errorRate || '0'),
      totalCalls: dailyStats.totalCalls,
      successCalls: dailyStats.successCalls,
      errorCalls: dailyStats.errorCalls,
      lastUpdate: parseInt(loadInfo.lastUpdate || '0')
    }
  }
}
```

## 总结

该注册中心设计提供了：

1. **统一管理**：PC 和云端智能体的统一注册和发现
2. **高性能**：多层缓存、分片存储、批量操作
3. **高可用**：故障转移、健康检查、自动恢复
4. **安全可控**：细粒度权限、访问审计、配额限制
5. **可扩展**：水平分片、负载均衡、性能监控

该注册中心设计为智能体生态系统提供了强大的发现和管理能力，支持多级共享、智能路由和高可用部署，是实现分布式智能体协作的核心基础设施。

---

## ⚠️ 实施人员必读

**关键提醒**: 在开始实施前，请务必阅读 `智能体实施关键信息.md` 文档，其中包含了架构理解、项目职责分工、常见陷阱等关键信息，避免实施走偏。

**注册中心要点**:
1. Redis键严格按 `roo:${userId}:` 格式，确保用户隔离
2. 共享索引支持多级别：私有→好友→群组→公开
3. 实例注册包含网络可达性状态
4. 心跳机制确保实例状态实时性

下一步将输出实施计划文档。