# 智能体实施计划

## 概述

本文档描述智能体持久化机制和 A2A 通信架构的分阶段实施计划。按照 KISS 原则，采用渐进式开发方式，确保每个阶段都能独立验证和使用。

## 实施原则

1. **渐进式开发**：每个阶段都有明确的可交付成果
2. **向下兼容**：新功能不破坏现有架构
3. **充分测试**：每个阶段都有完整的测试验证
4. **文档先行**：代码实现前先完善设计文档
5. **性能优先**：关键路径优化，非关键路径后续迭代

## 智能体架构概念澄清（基于正确项目理解）

### 核心设计原则
```
void项目 = 标准VSCode应用 (统一代码库)
运行环境：PC桌面 或 Docker容器 (相同应用，不同环境)

┌─────────────────────────────────────────────────────────────────┐
│                        void项目统一架构                          │
├─────────────────────────────────────────────────────────────────┤
│  void标准VSCode应用 (单一代码库)                                 │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │ void贡献点    wechat贡献点    roo-code扩展(built-in)        │ │
│  │ ┌─────────┐   ┌─────────┐    ┌─────────────────────────────┐ │ │
│  │ │ UI管理  │   │ IM界面  │    │ • AgentInstancePool        │ │ │
│  │ │ 状态显示│   │ 桥接界面│    │ • A2AServer (核心!)        │ │ │
│  │ │ 命令注册│   │ 权限管理│    │ • ResourceManager          │ │ │
│  │ └─────────┘   └─────────┘    │ • 后台执行引擎             │ │ │
│  │                              └─────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                ↓                                │
│  部署环境差异 (相同应用，不同网络策略)                            │
│  ┌──────────────────────┐        ┌──────────────────────┐        │
│  │    PC环境部署        │        │   Docker环境部署     │        │
│  │  (用户桌面)          │        │  (云端容器)          │        │
│  ├──────────────────────┤        ├──────────────────────┤        │
│  │ • localhost端点      │        │ • 容器IP端点         │        │
│  │ • 网络不可直达       │        │ • 公网可直达         │        │
│  │ • 依赖IM桥接         │        │ • 直连优先           │        │
│  │ • 本地文件存储       │        │ • 持久化存储         │        │
│  │ • 相同A2A服务器代码  │        │ • 相同A2A服务器代码  │        │
│  └──────────────────────┘        └──────────────────────┘        │
└─────────────────────────────────────────────────────────────────┘

关键理解：
• void是一个统一的VSCode应用，包含3个贡献点
• A2A服务器在roo-code扩展中实现，所有环境共享相同代码
• PC和Docker只是网络可达性不同，应用架构完全一致
• 智能体逻辑全部在roo-code扩展中，void只负责UI和命令注册
```

## 智能体架构演进路线图

```
                  完整生产级智能体系统架构演进 (19-25周)
    
阶段1: 基础持久化与后台运行 (3-4周)    阶段2: A2A通信与路由 (4-5周)
┌─────────────────────────┐        ┌─────────────────────────┐
│ Roo-Code扩展核心功能:   │   →    │ Roo-Code扩展A2A服务:   │
│ • 扩展AgentConfig       │        │ • A2AServer实现        │
│ • AgentInstanceRunner   │        │ • 网络探测服务         │
│ • ResourceManager       │        │ • IM桥接客户端         │
│ • Worker后台执行        │        │ • 智能路由策略         │
│ • Redis双向同步         │        │ • 权限验证中间件       │
│ • 共享范围字段支持      │        │ • A2A协议集成          │
└─────────────────────────┘        └─────────────────────────┘
           ↓                                  ↓
阶段3: void项目UI集成 (2-3周)        阶段4: box-im桥接服务 (4-5周)
┌─────────────────────────┐        ┌─────────────────────────┐
│ void贡献点UI层:         │   →    │ IM服务器端增强:        │
│ • 智能体管理界面        │        │ • AgentBridgeService   │
│ • 实例状态显示          │        │ • AgentMessageRouter   │
│ • 端点管理面板          │        │ • 权限代理验证         │
│ • 命令注册集成          │        │ • 跨网络消息中转       │
│ wechat贡献点:           │        │ • 智能体发现代理       │
│ • IM桥接状态显示        │        │ im-web客户端:          │
│ • 权限管理界面          │        │ • 桥接状态组件         │
└─────────────────────────┘        └─────────────────────────┘
           ↓                                  ↓
阶段5: 统一注册中心 (3-4周)          阶段6: 高级特性与监控 (3-4周)
┌─────────────────────────┐        ┌─────────────────────────┐
│ Redis注册中心完善:      │   →    │ 生产级特性:            │
│ • 多级别共享索引        │        │ • 多实例负载均衡       │
│ • 实例发现机制          │        │ • 细粒度权限控制       │
│ • 状态管理和心跳        │        │ • 实例健康检查         │
│ • 网络拓扑管理          │        │ • 审计日志系统         │
│ • 性能指标收集          │        │ • 性能监控告警         │
│ • 故障转移支持          │        │ • 容错机制完善         │
└─────────────────────────┘        └─────────────────────────┘

关键特性演进：
• 核心架构：阶段1后台运行 → 阶段2 A2A通信 → 阶段5注册中心 → 阶段6监控
• 项目集成：阶段3 void UI → 阶段4 box-im桥接 → 阶段6部署优化
• 用户体验：阶段1不干扰执行 → 阶段3管理界面 → 阶段6性能监控
```

## 总体时间规划（完整生产级）

| 阶段 | 名称 | 周期 | 主要项目 | 关键里程碑 |
|------|------|------|----------|------------|
| 第一阶段 | 基础持久化与后台运行 | 3-4周 | **Roo-Code** | AgentInstanceRunner + Worker后台执行 |
| 第二阶段 | A2A通信与路由 | 4-5周 | **Roo-Code** | A2AServer + 网络探测 + IM桥接客户端 |
| 第三阶段 | void项目UI集成 | 2-3周 | **void** | 智能体管理界面 + 状态显示 + 命令集成 |
| 第四阶段 | box-im桥接服务 | 4-5周 | **box-im** | AgentBridgeService + 消息路由 + 权限代理 |
| 第五阶段 | 统一注册中心 | 3-4周 | **多项目** | Redis注册中心 + 多级索引 + 实例发现 |
| 第六阶段 | 高级特性与监控 | 3-4周 | **多项目** | 负载均衡 + 健康检查 + 监控告警 |

**总计**: 19-25周 (约5-6个月)

## 第一阶段：基础持久化与后台运行 (3-4周)

### 目标
建立智能体后台运行机制和基础持久化架构，支持智能体配置的持久化存储和Worker线程隔离执行，确保智能体运行不干扰用户任务。

**核心交付物**：
- AgentInstanceRunner (Worker版本)
- ResourceManager 和资源监控
- 增强的AgentConfig数据结构  
- Redis双向同步机制

### 关键任务

#### 1.1 扩展数据结构 (3天)

**任务描述**：扩展智能体类型定义，实现定义与实例分离

**具体工作**：
```typescript
// 文件: packages/types/src/agent.ts

// 智能体定义（用户级别，与部署环境无关）
interface AgentConfig {
  // 现有字段保持不变
  id: string
  userId: string
  name: string
  // ...

  // 新增：共享和权限字段
  isPrivate: boolean                    // 默认 true
  shareScope?: 'friends' | 'groups' | 'public'  // 共享范围：好友、群组、公开
  shareLevel?: number                   // 共享级别：0=私有，1=好友，2=群组，3=公开
  a2aAgentCard?: A2AAgentCard          
  permissions?: AgentPermission[]       
  allowedUsers?: string[]              // 好友级别：白名单用户ID
  allowedGroups?: string[]             // 群组级别：白名单群组ID              
}

// 智能体实例（运行时环境相关）
interface AgentInstance {
  agentId: string                       // 关联的智能体定义ID
  instanceId: string                    // 实例唯一标识
  userId: string                        // 实例所属用户
  
  // 部署信息
  deployment: {
    type: 'pc' | 'cloud'                // 部署类型
    platform: 'vscode' | 'docker' | 'k8s'
    location: string                     // 部署位置描述
    version: string                      // void版本
  }
  
  // 网络端点
  endpoint: {
    url: string                          // HTTP服务端点
    networkReachable: boolean            // 是否网络可达
    lastProbeTime?: number              // 最后探测时间
    healthCheckPath: string             // 健康检查路径
  }
  
  // 实例状态
  status: {
    state: 'starting' | 'online' | 'offline' | 'error'
    startTime: number
    lastSeen: number
    currentLoad: number                 // 当前负载 0-1
    errorCount: number                  // 错误计数
  }
  
  // 性能指标
  metrics: {
    avgResponseTime: number             // 平均响应时间
    successRate: number                 // 成功率
    throughput: number                  // 吞吐量
    memoryUsage?: number                // 内存使用率
    cpuUsage?: number                   // CPU使用率
  }
}

interface A2AAgentCard {
  name: string
  description: string
  skills: string[]
  capabilities: {
    messageTypes: string[]
    taskTypes: string[]
    dataFormats: string[]
  }
}
```

**验收标准**：
- [ ] 智能体定义与实例类型分离清晰
- [ ] 类型定义编译通过
- [ ] 现有代码兼容性测试通过
- [ ] 类型文档更新完成
- [ ] 实例管理接口设计完成

#### 1.2 增强 VSCodeAgentStorageService (4天)

**任务描述**：在现有本地存储基础上增加新字段支持

**具体工作**：
```typescript
// 文件: src/core/agent/VSCodeAgentStorageService.ts
async createAgent(
  userId: string, 
  config: Omit<AgentConfig, "id" | "createdAt" | "updatedAt">
): Promise<AgentConfig> {
  const agent: AgentConfig = {
    ...config,
    id: this.generateAgentId(),
    userId,
    // 新增字段默认值
    isPrivate: config.isPrivate ?? true,
    shareLevel: config.isPrivate ? 0 : (config.shareLevel || 1),
    shareScope: config.isPrivate ? undefined : config.shareScope,
    a2aAgentCard: config.a2aAgentCard || this.generateDefaultA2ACard(config),
    permissions: config.permissions || [],
    allowedUsers: config.allowedUsers || [],
    allowedGroups: config.allowedGroups || [],
    createdAt: Date.now(),
    updatedAt: Date.now(),
  }
  
  // 现有逻辑保持不变
  const agents = await this.getUserAgents(userId)
  agents[agent.id] = agent
  await this.setUserAgents(userId, agents)
  
  return agent
}
```

**验收标准**：
- [ ] 新字段可以正确保存和读取
- [ ] 现有智能体数据迁移正常
- [ ] 单元测试覆盖新功能

#### 1.3 增强 AgentRedisSyncService (5天)

**任务描述**：扩展 Redis 同步机制，支持新的数据结构

**具体工作**：
```typescript
// 文件: src/core/agent/AgentRedisSyncService.ts
class AgentRedisSyncService {
  // 新增：同步智能体详细信息到 Redis
  private async syncAgentDetails(agent: AgentConfig): Promise<void> {
    const pipeline = this.redis.pipeline()
    
    // 基础信息
    pipeline.hset(
      `roo:agent:${agent.id}:details`,
      'data', JSON.stringify(agent),
      'lastUpdate', Date.now().toString()
    )
    
    // 能力索引
    for (const tool of agent.tools) {
      pipeline.sadd(`roo:capability:${tool.toolId}:agents`, agent.id)
    }
    
    // 共享索引 - 支持多级别索引
    if (!agent.isPrivate) {
      const shareLevel = agent.shareLevel || 1
      
      // 总共享索引
      pipeline.sadd('roo:shared:agents', agent.id)
      
      // 按级别分类索引
      pipeline.sadd(`roo:shared:agents:level:${shareLevel}`, agent.id)
      
      // 按范围分类索引
      switch (agent.shareScope) {
        case 'friends':
          pipeline.sadd('roo:shared:agents:friends', agent.id)
          break
        case 'groups':
          pipeline.sadd('roo:shared:agents:groups', agent.id)
          break
        case 'public':
          pipeline.sadd('roo:shared:agents:public', agent.id)
          break
      }
    }
    
    await pipeline.exec()
  }
}
```

**验收标准**：
- [ ] Redis 数据结构正确创建
- [ ] 同步机制稳定可靠
- [ ] 数据一致性检查通过
- [ ] 共享范围索引正确建立
- [ ] 多级别索引查询功能正常

#### 1.4 更新 EnhancedAgentStorageService (3天)

**任务描述**：集成新的同步逻辑

**具体工作**：
- 在创建智能体时自动生成 A2A 卡片
- 触发 Redis 同步
- 处理数据恢复场景

**验收标准**：
- [ ] 创建智能体时自动生成默认 A2A 信息
- [ ] Redis 同步在后台正常执行
- [ ] 数据恢复功能正常

#### 1.5 集成测试 (2天)

**任务描述**：端到端测试整个持久化流程

**测试场景**：
- 用户创建智能体
- 用户切换时数据同步
- Redis 不可用时的降级机制
- 数据冲突时的处理

### 第一阶段验收标准

- [ ] 智能体可以正常创建、读取、更新、删除
- [ ] 数据在本地和 Redis 之间正确同步
- [ ] 用户切换时智能体数据正确隔离
- [ ] 现有功能完全向下兼容
- [ ] 性能测试：创建智能体 < 500ms，读取 < 100ms

## 第二阶段：A2A基础通信 (2-3周)

### 目标
实现void项目的统一HTTP服务，支持PC端（localhost）和云端（公网）两种部署模式，集成IM桥接通信。

### 架构说明
```
void统一HTTP服务架构（同一套代码，自适应部署环境）

┌─────────────────────────────────────────────────────────────────┐
│                      void HTTP服务                              │
├─────────────────────────────────────────────────────────────────┤
│ • 同一套HTTP服务代码                                             │
│ • 运行时自动检测部署环境                                         │
│ • 自适应绑定地址和端口                                           │
│ • 统一的A2A协议端点                                              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
        ┌─────────────────────────────────────────┐
        │            部署环境自适应                 │
        └─────────────────────────────────────────┘
                              ↓
    ┌─────────────────┐              ┌─────────────────┐
    │   PC端部署      │              │   云端部署      │
    │ (VSCode扩展)    │              │ (Docker/K8s)   │
    ├─────────────────┤              ├─────────────────┤
    │ • 绑定localhost │              │ • 绑定0.0.0.0   │
    │ • 随机端口      │              │ • 配置端口      │
    │ • 网络不可达    │              │ • 网络可达      │
    │ • IM桥接必需    │              │ • 直连优先      │
    └─────────────────┘              └─────────────────┘
```

### 关键任务

#### 2.1 实现void统一HTTP服务 (6天)

**任务描述**：在void项目中实现自适应的HTTP服务，支持PC端和云端部署

**具体工作**：

```typescript
// 文件: src/core/agent/VoidAgentServer.ts
class VoidAgentServer {
  private app: express.Application
  private server: http.Server
  private deploymentType: 'pc' | 'cloud'
  
  async start(): Promise<void> {
    this.app = express()
    this.setupMiddleware()
    this.setupRoutes()
    
    // 自动检测部署环境
    this.deploymentType = this.detectDeploymentType()
    
    // 根据部署环境配置服务器
    const config = this.getServerConfig(this.deploymentType)
    
    this.server = this.app.listen(config.port, config.host, () => {
      const addr = this.server.address() as any
      console.log(`Void Agent Server (${this.deploymentType}) listening on ${config.host}:${addr.port}`)
      
      // 注册实例到注册中心
      this.registerInstance(addr.port)
    })
  }
  
  private detectDeploymentType(): 'pc' | 'cloud' {
    // 检测是否在容器环境中运行
    if (process.env.KUBERNETES_SERVICE_HOST || 
        process.env.DOCKER_CONTAINER ||
        process.env.VOID_DEPLOYMENT_TYPE === 'cloud') {
      return 'cloud'
    }
    return 'pc'
  }
  
  private getServerConfig(type: 'pc' | 'cloud') {
    switch (type) {
      case 'pc':
        return {
          host: '127.0.0.1',      // 仅localhost
          port: 0,                // 随机端口
          publicUrl: null         // 无公网URL
        }
      case 'cloud':
        return {
          host: '0.0.0.0',        // 监听所有接口
          port: process.env.VOID_AGENT_PORT || 8080,
          publicUrl: process.env.VOID_PUBLIC_URL // 公网URL
        }
    }
  }
}
```

**验收标准**：
- [ ] void HTTP服务可以在PC端和云端正常启动
- [ ] 部署环境自动检测准确
- [ ] A2A端点在两种环境下都正常工作
- [ ] 实例注册功能正常
- [ ] 环境适配逻辑正确

#### 2.2 实现 IM 桥接服务 (7天)

**任务描述**：基于现有 IM WebSocket 连接实现智能体代理

**具体工作**：

```typescript
// 文件: src/core/agent/AgentIMBridge.ts
class AgentIMBridge {
  private imConnection: RooCodeIMConnection
  private localServer: PCAgentServer
  
  async start(): Promise<void> {
    // 复用现有 IM 连接
    this.imConnection = new RooCodeIMConnection()
    await this.imConnection.connect()
    
    // 注册新的消息处理器
    this.setupAgentMessageHandlers()
    
    // 注册智能体到 IM
    await this.registerAgentToIM()
  }
  
  private setupAgentMessageHandlers(): void {
    // 智能体调用请求 (新增 cmd)
    this.imConnection.onMessage(26, this.handleAgentCall.bind(this))
    
    // 智能体流式请求 (新增 cmd)  
    this.imConnection.onMessage(27, this.handleAgentStream.bind(this))
  }
}
```

**验收标准**：
- [ ] IM 连接正常建立
- [ ] 智能体注册消息正确发送
- [ ] 代理调用功能正常

#### 2.3 实现 A2A 协议集成 (4天)

**任务描述**：集成 a2a-js SDK，实现标准协议

**具体工作**：
- 安装和配置 a2a-js 依赖
- 实现 AgentExecutor 接口
- 处理 A2A 消息格式

**验收标准**：
- [ ] a2a-js SDK 正确集成
- [ ] 智能体执行器正常工作
- [ ] 消息格式符合 A2A 标准

#### 2.4 基础路由实现 (3天)

**任务描述**：实现智能体发现和调用的基础路由

**具体工作**：

```typescript
// 文件: src/core/agent/AgentRoutingService.ts
class AgentRoutingService {
  async callAgent(
    targetAgentId: string,
    method: string,
    params: any
  ): Promise<any> {
    // 第二阶段：仅支持 IM 桥接
    return this.callViaIM(targetAgentId, method, params)
  }
  
  private async callViaIM(
    targetAgentId: string,
    method: string,
    params: any
  ): Promise<any> {
    const requestId = this.generateRequestId()
    
    // 发送到 IM
    this.imConnection.send({
      cmd: 26, // AGENT_CALL
      data: { requestId, targetAgentId, method, params }
    })
    
    // 等待响应
    return this.waitForResponse(requestId)
  }
}
```

**验收标准**：
- [ ] 智能体间调用功能正常
- [ ] 错误处理机制完善
- [ ] 超时机制正常工作

### 第二阶段验收标准

- [ ] PC 端智能体可以通过 IM 被其他智能体调用
- [ ] 智能体卡片信息正确暴露
- [ ] 基础的智能体间通信正常工作
- [ ] IM 桥接稳定可靠
- [ ] 性能测试：智能体调用 < 2s

## 第三阶段：统一注册中心 (2-3周)

### 目标
建立基于 Redis 的统一智能体注册中心，支持服务发现。

### 关键任务

#### 3.1 设计注册中心数据结构 (3天)

**任务描述**：在 Redis 中建立完整的智能体注册表

**具体工作**：
```typescript
// 文件: src/core/registry/AgentRedisKeys.ts
class AgentRedisKeys {
  static userAgents(userId: string): string {
    return `roo:${userId}:agents`
  }
  
  static agentDetails(agentId: string): string {
    return `roo:agent:${agentId}:details`
  }
  
  static onlineAgents(): string {
    return `roo:online:agents`
  }
  
  static sharedAgents(): string {
    return `roo:shared:agents`
  }
  
  // 共享范围相关索引
  static sharedAgentsByLevel(level: number): string {
    return `roo:shared:agents:level:${level}`
  }
  
  static friendsSharedAgents(): string {
    return `roo:shared:agents:friends`
  }
  
  static groupsSharedAgents(): string {
    return `roo:shared:agents:groups`
  }
  
  static publicSharedAgents(): string {
    return `roo:shared:agents:public`
  }
  
  static capabilityIndex(capability: string): string {
    return `roo:capability:${capability}:agents`
  }
}
```

**验收标准**：
- [ ] Redis 键结构设计合理
- [ ] 数据模型文档完整
- [ ] 索引策略清晰

#### 3.2 实现注册服务 (5天)

**任务描述**：实现统一的智能体注册服务

**具体工作**：
```typescript
// 文件: src/core/registry/UnifiedAgentRegistry.ts
class UnifiedAgentRegistry {
  async registerAgent(registry: UnifiedAgentRegistry): Promise<void> {
    const pipeline = this.redis.pipeline()
    
    // 保存详细信息
    pipeline.hset(
      AgentRedisKeys.agentDetails(registry.agentId),
      'data', JSON.stringify(registry)
    )
    
    // 更新索引
    pipeline.sadd(AgentRedisKeys.onlineAgents(), registry.agentId)
    
    if (!registry.sharing.isPrivate) {
      pipeline.sadd(AgentRedisKeys.sharedAgents(), registry.agentId)
    }
    
    await pipeline.exec()
  }
}
```

**验收标准**：
- [ ] 智能体注册功能正常
- [ ] 索引更新正确
- [ ] 并发安全

#### 3.3 实现服务发现 (5天)

**任务描述**：基于注册中心实现智能体发现

**具体工作**：
```typescript
// 文件: src/core/registry/AgentDiscoveryService.ts
class AgentDiscoveryService {
  async discoverAgents(query: AgentDiscoveryQuery): Promise<AgentDiscoveryResult[]> {
    // 1. 基于共享范围预过滤
    let candidates = await this.searchByShareScope(query.shareScope, query.shareLevel)
    
    // 2. 基于能力搜索
    if (query.capabilities?.length) {
      const capabilityCandidates = await this.searchByCapabilities(query.capabilities)
      candidates = this.intersectResults(candidates, capabilityCandidates)
    }
    
    // 3. 权限过滤 - 根据共享范围进行细粒度权限检查
    const authorized = await this.filterByPermissions(candidates, query.userId)
    
    // 4. 在线状态过滤
    const online = await this.filterOnlineAgents(authorized)
    
    return online
  }
  
  // 根据共享范围搜索智能体
  private async searchByShareScope(
    shareScope?: 'friends' | 'groups' | 'public', 
    shareLevel?: number
  ): Promise<string[]> {
    if (shareLevel !== undefined) {
      return await this.redis.smembers(`roo:shared:agents:level:${shareLevel}`)
    }
    
    if (shareScope) {
      switch (shareScope) {
        case 'friends':
          return await this.redis.smembers('roo:shared:agents:friends')
        case 'groups':
          return await this.redis.smembers('roo:shared:agents:groups')
        case 'public':
          return await this.redis.smembers('roo:shared:agents:public')
      }
    }
    
    // 默认返回所有共享智能体
    return await this.redis.smembers('roo:shared:agents')
  }
}
```

**验收标准**：
- [ ] 智能体发现功能正常
- [ ] 共享范围过滤准确
- [ ] 权限检查机制有效
- [ ] 查询性能满足要求 (< 200ms)

#### 3.4 状态管理和心跳 (4天)

**任务描述**：实现智能体状态管理和心跳机制

**具体工作**：
- 心跳上报机制
- 状态更新 TTL
- 离线检测和清理

**验收标准**：
- [ ] 心跳机制稳定
- [ ] 状态更新及时
- [ ] 离线检测准确

#### 3.5 集成现有服务 (3天)

**任务描述**：将注册中心集成到现有的智能体服务中

**具体工作**：
- 修改 AgentManager 集成注册中心
- 更新智能体创建流程
- 更新用户切换逻辑

**验收标准**：
- [ ] 注册中心无缝集成
- [ ] 现有功能不受影响
- [ ] 数据迁移正常

### 第三阶段验收标准

- [ ] 统一注册中心正常工作
- [ ] 智能体发现功能完善
- [ ] 状态管理实时准确
- [ ] 多用户智能体正确隔离
- [ ] 性能测试：发现智能体 < 200ms

## 第四阶段：实例发现与路由 (2-3周)

### 目标
实现智能体实例的自动发现、智能路由和负载均衡机制，支持同一智能体的多实例协同。

### 关键任务

#### 4.1 实例注册与发现 (5天)

**任务描述**：实现智能体实例的动态注册和发现机制

**具体工作**：
```typescript
// 文件: src/core/instance/AgentInstanceManager.ts
class AgentInstanceManager {
  // 实例注册
  async registerInstance(instance: AgentInstance): Promise<void> {
    // 1. 生成实例ID
    const instanceId = this.generateInstanceId(instance.agentId)
    instance.instanceId = instanceId
    
    // 2. 检测网络可达性
    instance.endpoint.networkReachable = await this.detectNetworkReachability(instance.endpoint.url)
    
    // 3. 注册到 Redis
    await this.registerToRedis(instance)
    
    // 4. 启动心跳
    this.startHeartbeat(instanceId)
  }
  
  // 实例发现
  async discoverInstances(agentId: string, options?: DiscoveryOptions): Promise<AgentInstance[]> {
    // 1. 从Redis获取实例列表
    const instances = await this.getInstancesFromRedis(agentId)
    
    // 2. 过滤在线实例
    const onlineInstances = instances.filter(i => i.status.state === 'online')
    
    // 3. 按负载排序
    return this.sortByLoad(onlineInstances, options?.preferenceType)
  }
  
  // 智能体实例选择
  async selectBestInstance(
    agentId: string, 
    requesterLocation?: string
  ): Promise<AgentInstance | null> {
    const instances = await this.discoverInstances(agentId)
    if (instances.length === 0) return null
    
    // 负载均衡算法选择最优实例
    return this.loadBalanceSelection(instances, requesterLocation)
  }
}
```

**验收标准**：
- [ ] 实例注册机制正常工作
- [ ] 实例发现功能准确
- [ ] 网络可达性检测有效
- [ ] 负载均衡算法合理
- [ ] 心跳机制稳定
- [ ] 公网访问正常
- [ ] 认证机制工作

#### 4.2 智能路由实现 (7天)

**任务描述**：实现智能路由，支持直连和 IM 两种模式

**具体工作**：
```typescript
// 文件: src/core/agent/AgentRoutingService.ts (完整版)
class AgentRoutingService {
  async routeToAgent(
    sourceAgentId: string,
    targetAgentId: string,
    request: AgentRequest
  ): Promise<AgentResponse> {
    const targetEndpoint = await this.getEndpoint(targetAgentId)
    const route = await this.selectRoute(targetEndpoint)
    
    switch (route) {
      case 'direct':
        return this.directCall(targetEndpoint, request)
      case 'im_bridge':
        return this.imBridgeCall(targetEndpoint, request)
      case 'hybrid':
        return this.hybridCall(targetEndpoint, request)
    }
  }
}
```

**验收标准**：
- [ ] 路由决策算法正确
- [ ] 直连调用功能正常
- [ ] 故障转移机制工作

#### 4.3 端点管理 (4天)

**任务描述**：实现智能体端点的动态管理

**具体工作**：
- 端点注册和更新
- 健康检查
- 端点失效处理

**验收标准**：
- [ ] 端点信息正确维护
- [ ] 健康检查准确
- [ ] 失效端点及时清理

#### 4.4 API 密钥管理 (3天)

**任务描述**：实现云端智能体的安全认证

**具体工作**：
- API 密钥生成和管理
- 请求认证中间件
- 密钥轮换机制

**验收标准**：
- [ ] API 密钥安全可靠
- [ ] 认证机制正确
- [ ] 密钥管理完善

### 第四阶段验收标准

- [ ] 智能体实例可以正常注册和发现
- [ ] 多实例负载均衡正确工作
- [ ] 智能路由正确选择最优实例
- [ ] 网络探测和故障转移稳定
- [ ] 性能测试：实例选择 < 100ms，调用 < 500ms

## 第五阶段：高级特性 (3-4周)

### 目标
实现负载均衡、权限控制、配额管理等高级特性。

### 关键任务

#### 5.1 负载均衡器 (6天)

**任务描述**：实现智能体的负载均衡和故障转移

**具体工作**：
```typescript
// 文件: src/core/agent/AgentLoadBalancer.ts
class AgentLoadBalancer {
  async selectOptimalAgent(
    capability: string,
    userId: string
  ): Promise<AgentEndpoint> {
    const candidates = await this.getCandidateAgents(capability, userId)
    return this.weightedRoundRobin(candidates)
  }
  
  private weightedRoundRobin(agents: AgentEndpoint[]): AgentEndpoint {
    // 实现加权轮询算法
  }
}
```

**验收标准**：
- [ ] 负载均衡算法正确
- [ ] 性能指标收集准确
- [ ] 故障检测及时

#### 5.2 权限控制系统 (7天)

**任务描述**：实现细粒度的权限控制

**具体工作**：
```typescript
// 文件: src/core/agent/AgentPermissionService.ts
class AgentPermissionService {
  async checkAccess(
    userId: string,
    agentId: string,
    action: string
  ): Promise<AccessResult> {
    const agent = await this.getAgent(agentId)
    if (!agent) {
      return { allowed: false, reason: 'Agent not found' }
    }
    
    // 1. 所有者永远有权限
    if (agent.userId === userId) {
      return { allowed: true, reason: 'Owner access' }
    }
    
    // 2. 私有智能体只有所有者可访问
    if (agent.isPrivate || agent.shareLevel === 0) {
      return { allowed: false, reason: 'Private agent' }
    }
    
    // 3. 根据共享范围检查权限
    switch (agent.shareScope) {
      case 'friends':
        // 好友级别：检查好友白名单
        if (agent.allowedUsers?.includes(userId)) {
          return { allowed: true, reason: 'Friend access' }
        }
        // TODO: 检查好友关系
        return { allowed: false, reason: 'Not in friends list' }
        
      case 'groups':
        // 群组级别：检查群组白名单或共同群组
        if (agent.allowedGroups?.length) {
          const userGroups = await this.getUserGroups(userId)
          const hasGroupAccess = agent.allowedGroups.some(group =>
            userGroups.includes(group)
          )
          if (hasGroupAccess) {
            return { allowed: true, reason: 'Group access' }
          }
        }
        return { allowed: false, reason: 'Not in allowed groups' }
        
      case 'public':
        // 公开级别：所有人可读，执行需要额外检查
        if (action === 'read' || action === 'execute') {
          return { allowed: true, reason: 'Public access' }
        }
        return { allowed: false, reason: 'Action not allowed for public' }
        
      default:
        return { allowed: false, reason: 'Unknown share scope' }
    }
  }
  
  private async getUserGroups(userId: string): Promise<string[]> {
    // TODO: 实现用户群组查询逻辑
    return []
  }
}
```

**验收标准**：
- [ ] 权限检查逻辑正确
- [ ] 访问控制粒度合适
- [ ] 性能影响可接受

#### 5.3 配额和限流 (5天)

**任务描述**：实现配额管理和请求限流

**具体工作**：
- 用户配额管理
- 请求速率限制
- 超额处理机制

**验收标准**：
- [ ] 配额管理准确
- [ ] 限流机制有效
- [ ] 超额处理合理

#### 5.4 审计日志 (4天)

**任务描述**：实现完整的审计日志系统

**具体工作**：
- 操作日志记录
- 访问日志统计
- 日志查询接口

**验收标准**：
- [ ] 日志记录完整
- [ ] 查询性能良好
- [ ] 存储空间可控

### 第五阶段验收标准

- [ ] 负载均衡正确分发请求
- [ ] 权限控制安全可靠
- [ ] 配额管理功能完善
- [ ] 审计日志记录完整
- [ ] 系统整体稳定性良好

## 第六阶段：性能优化 (2-3周)

### 目标
对整个系统进行性能优化，添加监控和告警。

### 关键任务

#### 6.1 缓存优化 (5天)

**任务描述**：实现多层缓存提升性能

**具体工作**：
- 本地缓存实现
- Redis 缓存策略
- 缓存失效机制

**验收标准**：
- [ ] 缓存命中率 > 80%
- [ ] 响应时间明显改善
- [ ] 缓存一致性保证

#### 6.2 连接池优化 (4天)

**任务描述**：优化网络连接管理

**具体工作**：
- HTTP 连接池
- Redis 连接复用
- 连接健康检查

**验收标准**：
- [ ] 连接复用率高
- [ ] 连接泄露防护
- [ ] 并发性能提升

#### 6.3 监控告警 (6天)

**任务描述**：建立完整的监控告警体系

**具体工作**：
```typescript
// 文件: src/core/monitoring/AgentMonitoringService.ts
class AgentMonitoringService {
  async collectMetrics(): Promise<SystemMetrics> {
    return {
      totalAgents: await this.getTotalAgents(),
      onlineAgents: await this.getOnlineAgents(),
      avgResponseTime: await this.getAverageResponseTime(),
      errorRate: await this.getErrorRate(),
      throughput: await this.getThroughput()
    }
  }
}
```

**验收标准**：
- [ ] 关键指标监控完整
- [ ] 告警及时准确
- [ ] 监控面板可用

#### 6.4 性能测试和调优 (5天)

**任务描述**：全面的性能测试和调优

**测试场景**：
- 高并发智能体注册
- 大量智能体发现查询
- 复杂路由场景测试
- 故障恢复测试

**验收标准**：
- [ ] 并发注册 > 100 agents/s
- [ ] 发现查询 < 100ms (P99)
- [ ] 智能体调用 < 1s (P95)
- [ ] 系统可用性 > 99.9%

### 第六阶段验收标准

- [ ] 整体系统性能达标
- [ ] 监控告警体系完善
- [ ] 文档和运维手册完整
- [ ] 生产环境就绪

## 质量保证计划

### 测试策略

#### 单元测试
- **覆盖率要求**：核心模块 > 90%
- **测试工具**：Jest + TypeScript
- **持续集成**：每次 PR 自动运行

#### 集成测试
- **端到端测试**：模拟完整的智能体交互流程
- **多用户测试**：验证用户隔离和权限控制
- **故障注入测试**：验证容错和恢复能力

#### 性能测试
- **负载测试**：模拟高并发场景
- **压力测试**：确定系统极限
- **稳定性测试**：长时间运行验证

### 代码质量

#### 代码规范
- **ESLint 配置**：严格的 TypeScript 规范
- **Prettier 格式化**：统一代码风格
- **提交规范**：Conventional Commits

#### 代码审查
- **PR Review**：至少一人审查
- **架构审查**：关键模块架构师审查
- **安全审查**：涉及权限的模块安全审查

### 文档标准

#### API 文档
- **OpenAPI 规范**：所有 HTTP 接口
- **TypeScript 注释**：详细的类型说明
- **示例代码**：完整的使用示例

#### 运维文档
- **部署指南**：详细的部署步骤
- **配置说明**：所有配置项的说明
- **故障排查**：常见问题和解决方案

## 风险评估和应对

### 技术风险

#### Redis 性能瓶颈
- **风险描述**：大量智能体注册可能导致 Redis 性能问题
- **影响评估**：高
- **应对方案**：
  - 实现 Redis 分片
  - 增加本地缓存
  - 异步写入策略

#### IM 连接稳定性
- **风险描述**：IM WebSocket 连接不稳定影响桥接功能
- **影响评估**：中
- **应对方案**：
  - 强化重连机制
  - 增加连接健康检查
  - 实现请求队列

#### VSCode 扩展进程限制
- **风险描述**：VSCode 扩展进程资源限制影响服务性能
- **影响评估**：中
- **应对方案**：
  - 优化内存使用
  - 异步处理长任务
  - 资源使用监控

### 业务风险

#### 用户数据安全
- **风险描述**：智能体数据泄露或权限绕过
- **影响评估**：高
- **应对方案**：
  - 严格的权限检查
  - 数据加密传输
  - 完整的审计日志

#### 向下兼容性
- **风险描述**：新功能破坏现有用户体验
- **影响评估**：高
- **应对方案**：
  - 渐进式升级
  - 兼容性测试
  - 回滚机制

### 项目风险

#### 开发进度延期
- **风险描述**：复杂度超预期导致开发延期
- **影响评估**：中
- **应对方案**：
  - 分阶段交付
  - 定期里程碑检查
  - 备选方案准备

#### 资源投入不足
- **风险描述**：开发资源不足影响质量
- **影响评估**：中
- **应对方案**：
  - 优先级排序
  - 外部资源补充
  - 范围调整

## 成功标准

### 功能完整性
- [ ] 智能体创建、管理、发现功能完整
- [ ] PC 端和云端智能体都能正常工作
- [ ] 智能体间通信稳定可靠
- [ ] 权限控制和配额管理有效

### 性能指标
- [ ] 智能体注册 < 500ms
- [ ] 智能体发现 < 200ms
- [ ] 智能体调用 < 2s (IM桥接) / < 500ms (直连)
- [ ] 系统可用性 > 99.9%

### 用户体验
- [ ] 现有功能完全兼容
- [ ] 新功能学习成本低
- [ ] 错误提示清晰明确
- [ ] 文档完整易懂

### 技术指标
- [ ] 代码覆盖率 > 90%
- [ ] 技术债务可控
- [ ] 安全漏洞为零
- [ ] 性能基准达标

## 总结

本实施计划采用渐进式开发方式，确保每个阶段都有明确的可交付成果。通过合理的任务分解、严格的质量控制和全面的风险管控，能够稳步推进智能体持久化机制和 A2A 通信架构的建设，最终实现一个功能完整、性能优良、安全可靠的智能体生态系统。

关键成功因素：
1. **严格按阶段推进**，确保每个里程碑的质量
2. **持续集成测试**，及早发现和解决问题
3. **充分的技术预研**，避免架构性风险
4. **完善的文档和培训**，确保团队协作效率

---

## ⚠️ 实施人员必读

**关键提醒**: 在开始实施前，请务必阅读 `智能体实施关键信息.md` 文档，其中包含了架构理解、项目职责分工、常见陷阱等关键信息，避免实施走偏。

**实施要点**:
1. 按阶段严格执行，每阶段有明确验收标准
2. Roo-Code是核心实现项目，包含所有智能体逻辑
3. void和box-im分别负责UI和桥接，不要混淆职责
4. 优先使用Worker线程实现后台运行机制

**开始实施前务必确认**:
- ✅ 已理解void项目的统一架构(3个贡献点)
- ✅ 已明确A2AServer在roo-code扩展中实现
- ✅ 已了解PC和Docker环境的网络策略差异
- ✅ 已掌握Redis用户隔离的键命名规范
5. **用户反馈驱动**，确保产品符合实际需求